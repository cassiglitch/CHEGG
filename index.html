<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>CHEGG Card Game Variant – Custom Deck, Mana, AI, & Recycle Discards</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        background: #f4f4f4;
        margin: 0;
        padding: 10px;
      }
      h1, h2 {
        text-align: center;
      }
      #gameContainer, #deckBuilderContainer {
        max-width: 1200px;
        margin: 0 auto;
        background: #fff;
        padding: 10px;
        box-shadow: 0 0 10px rgba(0,0,0,0.2);
      }
      .section {
        margin-bottom: 15px;
      }
      .area {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 5px;
        border: 1px solid #ccc;
        background: #e9e9e9;
        margin-bottom: 5px;
      }
      .battlefield, .hand, .biomeZone, .deckArea {
        min-height: 80px;
        padding: 5px;
        border: 1px dashed #888;
        background: #fff;
        margin: 5px 0;
      }
      .card, .minion, .deckCard {
        display: inline-block;
        border: 1px solid #333;
        border-radius: 4px;
        background: #fafafa;
        padding: 5px;
        margin: 5px;
        cursor: pointer;
        white-space: pre-line;
      }
      .selected {
        border: 2px solid #f80;
        background: #fffae6;
      }
      #message {
        margin-top: 10px;
        padding: 5px;
        background: #eef;
        border: 1px solid #99f;
      }
      #controls {
        text-align: center;
        margin-top: 10px;
      }
      button {
        margin: 5px;
        padding: 8px 16px;
        font-size: 16px;
      }
      .info {
        font-size: 18px;
      }
      .biomeZone {
        font-style: italic;
        text-align: center;
      }
      /* Deck builder styles */
      #deckBuilderContainer {
        margin-bottom: 20px;
      }
      #availableCards, #selectedDeck {
        border: 1px solid #888;
        padding: 5px;
        min-height: 120px;
        background: #fff;
        margin: 5px 0;
      }
      .deckCard {
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <!-- DECK BUILDER VIEW -->
    <div id="deckBuilderContainer">
      <h1>Deck Builder</h1>
      <p>Select up to 15 cards for your deck. You may add minions, spells, or biome cards.</p>
      <div class="section">
        <h2>Available Cards</h2>
        <div id="availableCards" class="deckArea"></div>
      </div>
      <div class="section">
        <h2>Your Deck (<span id="deckCount">0</span>/15)</h2>
        <div id="selectedDeck" class="deckArea"></div>
      </div>
      <div class="section" style="text-align:center;">
        <button onclick="saveDeck()">Save Deck</button>
        <input type="file" id="loadDeckFile" accept=".json" onchange="loadDeck(event)">
        <button onclick="startGame()">Start Game</button>
      </div>
    </div>

    <!-- GAME VIEW -->
    <div id="gameContainer" style="display:none;">
      <h1>CHEGG Card Game Variant – Custom Deck, Mana, AI, & Recycling</h1>
      <!-- Opponent Info -->
      <div class="section">
        <div class="area">
          <div>
            <strong>Opponent Villager</strong><br>
            <span id="opponentHeroHP" class="info"></span>
          </div>
          <div>
            <strong>Opponent Mana</strong><br>
            <span id="opponentMana" class="info"></span>
          </div>
        </div>
        <div class="area">
          <div style="width:32%;">
            <strong>Opponent Biome</strong>
            <div id="opponentBiome" class="biomeZone"></div>
          </div>
          <div style="width:32%;">
            <strong>Opponent Battlefield</strong>
            <div id="opponentBattlefield" class="battlefield"></div>
          </div>
          <div style="width:32%;">
            <strong>Opponent Hand</strong>
            <div id="opponentHand" class="hand"></div>
          </div>
        </div>
      </div>
      
      <!-- Player Info -->
      <div class="section">
        <div class="area">
          <div>
            <strong>Your Villager</strong><br>
            <span id="playerHeroHP" class="info"></span>
          </div>
          <div>
            <strong>Your Mana</strong><br>
            <span id="playerMana" class="info"></span>
          </div>
        </div>
        <div class="area">
          <div style="width:32%;">
            <strong>Your Biome</strong>
            <div id="playerBiome" class="biomeZone"></div>
          </div>
          <div style="width:32%;">
            <strong>Your Battlefield</strong>
            <div id="playerBattlefield" class="battlefield"></div>
          </div>
          <div style="width:32%;">
            <strong>Your Hand</strong>
            <div id="handContainer" class="hand"></div>
          </div>
        </div>
      </div>
      
      <!-- Controls -->
      <div id="controls" class="section">
        <button onclick="endTurn()" id="endTurnButton">End Turn</button>
        <button onclick="activateSelectedAbility()" id="activateAbilityButton" style="display:none;">Activate Ability</button>
        <button onclick="resetGame()">Reset Game</button>
      </div>
      
      <!-- Message Log -->
      <div id="message" class="section">Welcome to CHEGG Card Game!</div>
    </div>
    
    <script>
      /***** GAME CONFIGURATION *****/
      const MAX_MANA = 6;
      const STARTING_HP = 20;
      const ATTACK_COST = 1; // Each attack costs 1 mana

      // Card templates with elemental properties.
      const cardTemplates = {
        "Villager": { 
          type: "hero", 
          name: "Villager", 
          cost: 0, 
          attack: 0, 
          hp: STARTING_HP 
        },
        "Zombie": { 
          type: "minion", 
          name: "Zombie", 
          cost: 1, 
          attack: 1, 
          hp: 1, 
          element: "undead", 
          strengths: [], 
          weaknesses: ["fire"] 
        },
        "Creeper": { 
          type: "minion", 
          name: "Creeper", 
          cost: 1, 
          attack: 1, 
          hp: 1, 
          element: "undead", 
          strengths: [], 
          weaknesses: ["water"],
          ability: "explode" 
        },
        "Pig": { 
          type: "minion", 
          name: "Pig", 
          cost: 1, 
          attack: 0, 
          hp: 1, 
          element: "beast", 
          strengths: [], 
          weaknesses: [],
          ability: "support" 
        },
        "Rabbit": { 
          type: "minion", 
          name: "Rabbit", 
          cost: 2, 
          attack: 1, 
          hp: 1, 
          element: "beast", 
          strengths: [], 
          weaknesses: [],
          ability: "hop" 
        },
        "PufferFish": { 
          type: "minion", 
          name: "Puffer-Fish", 
          cost: 2, 
          attack: 1, 
          hp: 1, 
          element: "water", 
          strengths: ["fire"], 
          weaknesses: ["electric"],
          ability: "splash" 
        },
        "IronGolem": { 
          type: "minion", 
          name: "Iron-Golem", 
          cost: 2, 
          attack: 2, 
          hp: 3, 
          element: "earth", 
          strengths: ["undead"], 
          weaknesses: ["water"],
          ability: "sweep" 
        },
        "Frog": { 
          type: "minion", 
          name: "Frog", 
          cost: 2, 
          attack: 0, 
          hp: 2, 
          element: "water", 
          strengths: [], 
          weaknesses: ["fire"],
          ability: "pull" 
        },
        "Skeleton": { 
          type: "minion", 
          name: "Skeleton", 
          cost: 3, 
          attack: 3, 
          hp: 2, 
          element: "undead", 
          strengths: [], 
          weaknesses: ["fire"] 
        },
        "Blaze": { 
          type: "minion", 
          name: "Blaze", 
          cost: 3, 
          attack: 3, 
          hp: 2, 
          element: "fire", 
          strengths: ["undead"], 
          weaknesses: ["water"],
          ability: "ranged" 
        },
        "Phantom": { 
          type: "minion", 
          name: "Phantom", 
          cost: 3, 
          attack: 2, 
          hp: 1, 
          element: "air", 
          strengths: [], 
          weaknesses: ["earth"],
          ability: "shadow" 
        },
        "Enderman": { 
          type: "minion", 
          name: "Enderman", 
          cost: 4, 
          attack: 3, 
          hp: 2, 
          element: "dark", 
          strengths: [], 
          weaknesses: ["light"],
          ability: "teleport" 
        },
        "Slime": { 
          type: "minion", 
          name: "Slime", 
          cost: 4, 
          attack: 2, 
          hp: 3, 
          element: "earth", 
          strengths: [], 
          weaknesses: ["fire"],
          ability: "jump" 
        },
        "ShulkerBox": { 
          type: "minion", 
          name: "Shulker-Box", 
          cost: 4, 
          attack: 1, 
          hp: 4, 
          element: "metal", 
          strengths: [], 
          weaknesses: ["earth"],
          ability: "longshot" 
        },
        "Parrot": { 
          type: "minion", 
          name: "Parrot", 
          cost: 5, 
          attack: 3, 
          hp: 2, 
          element: "air", 
          strengths: [], 
          weaknesses: ["electric"],
          ability: "copy" 
        },
        "Cat": { 
          type: "minion", 
          name: "Cat", 
          cost: 5, 
          attack: 0, 
          hp: 2, 
          element: "beast", 
          strengths: [], 
          weaknesses: [],
          ability: "manaBoost" 
        },
        "Sniffer": { 
          type: "minion", 
          name: "Sniffer", 
          cost: 5, 
          attack: 2, 
          hp: 2, 
          element: "beast", 
          strengths: [], 
          weaknesses: [],
          ability: "disrupt" 
        },
        "Wither": { 
          type: "minion", 
          name: "Wither", 
          cost: 6, 
          attack: 4, 
          hp: 3, 
          element: "undead", 
          strengths: ["beast"], 
          weaknesses: ["fire"],
          ability: "explosiveWither" 
        },
        "Reinforcement": { 
          type: "spell", 
          name: "Reinforcement", 
          cost: 2, 
          effect: "draw2" 
        },
        "Lightning": { 
          type: "spell", 
          name: "Lightning", 
          cost: 3, 
          effect: "lightning", 
          damage: 3 
        },
        "Heal": { 
          type: "spell", 
          name: "Heal", 
          cost: 3, 
          effect: "heal", 
          amount: 3 
        },
        "Forest": { 
          type: "biome", 
          name: "Forest", 
          cost: 3, 
          effect: "boost", 
          elementTarget: "beast", 
          bonus: 1 
        },
        "Desert": { 
          type: "biome", 
          name: "Desert", 
          cost: 3, 
          effect: "weaken", 
          elementTarget: "water", 
          penalty: 1 
        }
      };
      
      /***** GAME STATE *****/
      let currentTurn = "player"; // "player" or "ai"
      let turnNumber = 1;
      
      let player = {
        hero: null,
        deck: [], // Loaded via deck builder
        hand: [],
        battlefield: [],
        biome: null,
        discard: [], // Discard pile for recycling cards
        currentMana: 0,
        maxMana: 0
      };
      
      let ai = {
        hero: null,
        deck: [], // Default deck for AI
        hand: [],
        battlefield: [],
        biome: null,
        discard: [],
        currentMana: 0,
        maxMana: 0
      };
      
      // For selecting a minion for attack/ability activation.
      let selectedAttacker = null;
      
      /***** DECK BUILDER FUNCTIONS *****/
      const availableCardKeys = Object.keys(cardTemplates).filter(key => {
        let type = cardTemplates[key].type;
        return (type === "minion" || type === "spell" || type === "biome");
      });
      
      function populateAvailableCards() {
        let container = document.getElementById("availableCards");
        container.innerHTML = "";
        availableCardKeys.forEach(key => {
          let card = cardTemplates[key];
          let div = document.createElement("div");
          div.className = "deckCard";
          div.innerText = card.name + "\nCost: " + card.cost;
          div.onclick = () => addCardToDeck(key);
          container.appendChild(div);
        });
      }
      
      function addCardToDeck(cardKey) {
        if (player.deck.length >= 15) {
          alert("Deck limit reached (15 cards).");
          return;
        }
        player.deck.push(cardKey);
        updateDeckCount();
        populateSelectedDeck();
      }
      
      function updateDeckCount() {
        document.getElementById("deckCount").innerText = player.deck.length;
      }
      
      function populateSelectedDeck() {
        let container = document.getElementById("selectedDeck");
        container.innerHTML = "";
        player.deck.forEach((cardKey, idx) => {
          let card = cardTemplates[cardKey];
          let div = document.createElement("div");
          div.className = "deckCard";
          div.innerText = card.name + "\nCost: " + card.cost;
          div.onclick = () => { 
            player.deck.splice(idx, 1);
            updateDeckCount();
            populateSelectedDeck();
          };
          container.appendChild(div);
        });
      }
      
      function saveDeck() {
        if (player.deck.length === 0) {
          alert("Your deck is empty!");
          return;
        }
        const data = JSON.stringify(player.deck);
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = "deck.json";
        a.click();
        URL.revokeObjectURL(url);
      }
      
      function loadDeck(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const loadedDeck = JSON.parse(e.target.result);
            if (Array.isArray(loadedDeck) && loadedDeck.length <= 15) {
              player.deck = loadedDeck;
              updateDeckCount();
              populateSelectedDeck();
            } else {
              alert("Invalid deck file.");
            }
          } catch (err) {
            alert("Error reading deck file.");
          }
        };
        reader.readAsText(file);
      }
      
      function resetDeckBuilder() {
        player.deck = [];
        updateDeckCount();
        populateSelectedDeck();
      }
      
      /***** DRAW CARD FUNCTION (with Recycle) *****/
      function drawCard(side) {
        let p = (side === "player") ? player : ai;
        // If deck is empty, recycle discard pile.
        if (p.deck.length === 0 && p.discard.length > 0) {
          logMessage(side + "'s deck is empty. Recycling discard pile.");
          p.deck = shuffleArray(p.discard);
          p.discard = [];
        }
        if (p.deck.length > 0) {
          let cardKey = p.deck.shift();
          p.hand.push(cardKey);
          logMessage(side + " drew a card: " + cardTemplates[cardKey].name);
        } else {
          logMessage(side + " has no cards left to draw!");
        }
      }
      
      /***** GAME FUNCTIONS *****/
      // When starting the game, hide the deck builder and initialize game state.
      function startGame() {
        if (player.deck.length === 0) {
          alert("Please build a deck (up to 15 cards) before starting the game.");
          return;
        }
        document.getElementById("deckBuilderContainer").style.display = "none";
        document.getElementById("gameContainer").style.display = "block";
        // Shuffle player's deck.
        player.deck = shuffleArray(player.deck);
        // Build AI default deck.
        ai.deck = buildDefaultAIDeck();
        ai.deck = shuffleArray(ai.deck);
        initGame();
      }
      
      function shuffleArray(array) {
        return array.sort(() => Math.random() - 0.5);
      }
      
      function buildDefaultAIDeck() {
        const defaultKeys = ["Zombie", "Skeleton", "Blaze", "Reinforcement", "Lightning", "Forest", "Cat", "Rabbit", "Pig", "Enderman", "Heal", "Desert", "Frog", "Creeper", "Sniffer"];
        return defaultKeys;
      }
      
      /***** GAME STATE INITIALIZATION *****/
      function initGame() {
        turnNumber = 1;
        currentTurn = "player";
        selectedAttacker = null;
        player.biome = null;
        ai.biome = null;
        player.discard = [];
        ai.discard = [];
        
        // Create heroes.
        player.hero = Object.assign({}, cardTemplates["Villager"]);
        ai.hero = Object.assign({}, cardTemplates["Villager"]);
        
        // Clear hands and battlefields.
        player.hand = [];
        ai.hand = [];
        player.battlefield = [];
        ai.battlefield = [];
        
        // For starting hand, draw 5 random cards from player's deck.
        for (let i = 0; i < 5; i++) {
          if (player.deck.length > 0) {
            let randIndex = Math.floor(Math.random() * player.deck.length);
            let cardKey = player.deck.splice(randIndex, 1)[0];
            player.hand.push(cardKey);
          }
        }
        // For AI, draw the first 5 cards.
        for (let i = 0; i < 5; i++) {
          if (ai.deck.length > 0) {
            let cardKey = ai.deck.shift();
            ai.hand.push(cardKey);
          }
        }
        
        // Initialize mana (starting at 1).
        player.maxMana = 1;
        player.currentMana = 1;
        ai.maxMana = 1;
        ai.currentMana = 1;
        
        updateUI();
        logMessage("Game started! Your turn begins.");
        // For the very first turn, do not ramp player's mana.
        startTurn("player");
      }
      
      /***** TURN MANAGEMENT *****/
      function startTurn(side) {
        currentTurn = side;
        if (side === "player") {
          // For player's turn, if not turn 1 then ramp mana.
          if (turnNumber > 1) {
            player.maxMana = Math.min(player.maxMana + 1, MAX_MANA);
            if (player.battlefield.some(m => m.name === "Cat")) {
              player.maxMana = Math.min(player.maxMana + 1, MAX_MANA);
            }
          }
          turnNumber++;
          player.currentMana = player.maxMana;
          drawCard("player");
          logMessage("Your turn. You have " + player.currentMana + " mana.");
          updateUI();
        } else {
          ai.maxMana = Math.min(ai.maxMana + 1, MAX_MANA);
          ai.currentMana = ai.maxMana;
          drawCard("ai");
          logMessage("AI turn. AI has " + ai.currentMana + " mana.");
          updateUI();
          setTimeout(aiTurn, 1000);
        }
      }
      
      function endTurn() {
        if (currentTurn !== "player") return;
        logMessage("Ending your turn.");
        player.battlefield.forEach(m => { m.attacked = false; m.abilityUsed = false; });
        currentTurn = "ai";
    ai.maxMana = Math.min(ai.maxMana + 1, MAX_MANA);
ai.currentMana = ai.maxMana;
        updateUI();
        setTimeout(aiTurn, 1000);
      }
      
      /***** PLAYER ACTIONS *****/
      function playCard(index) {
        if (currentTurn !== "player") return;
        let cardKey = player.hand[index];
        let cardTemplate = cardTemplates[cardKey];
        if (player.currentMana < cardTemplate.cost) {
          logMessage("Not enough mana to play " + cardTemplate.name + ".");
          return;
        }
        player.currentMana -= cardTemplate.cost;
        player.hand.splice(index, 1);
        // After playing, add spell cards to discard.
        if (cardTemplate.type === "biome") {
          player.biome = Object.assign({}, cardTemplate);
          logMessage("You set your biome to " + cardTemplate.name + ".");
          // Recycle biome card immediately.
          player.discard.push(cardKey);
        }
        else if (cardTemplate.type === "minion") {
          let minion = Object.assign({}, cardTemplate);
          // Store cardKey so that if the minion is defeated it can be recycled.
          minion.cardKey = cardKey;
          minion.currentHP = cardTemplate.hp;
          minion.attacked = false;
          minion.abilityUsed = false;
          player.battlefield.push(minion);
          if (minion.ability === "support") {
            drawCard("player");
            logMessage("Pig's support activated: you draw 1 card.");
          }
          logMessage("You summoned a " + minion.name + ".");
        } else if (cardTemplate.type === "spell") {
          if (cardTemplate.effect === "draw2") {
            drawCard("player");
            drawCard("player");
            logMessage("You cast Reinforcement and drew 2 cards.");
          } else if (cardTemplate.effect === "lightning") {
            if (ai.battlefield.length > 0) {
              ai.battlefield[0].currentHP -= cardTemplate.damage;
              logMessage("You cast Lightning on " + ai.battlefield[0].name + " for " + cardTemplate.damage + " damage.");
              if (ai.battlefield[0].currentHP <= 0) {
                logMessage(ai.battlefield[0].name + " was destroyed.");
                // Recycle defeated minion.
                ai.discard.push(ai.battlefield[0].cardKey || "Lightning");
                ai.battlefield.shift();
              }
            } else {
              ai.hero.hp -= cardTemplate.damage;
              logMessage("You cast Lightning on the opponent's Villager for " + cardTemplate.damage + " damage.");
            }
          } else if (cardTemplate.effect === "heal") {
            player.hero.hp += cardTemplate.amount;
            logMessage("You cast Heal and restored " + cardTemplate.amount + " HP to your Villager.");
          }
          // Recycle spell card.
          player.discard.push(cardKey);
        }
        updateUI();
      }
      
      function selectAttacker(index) {
        if (currentTurn !== "player") return;
        let attacker = player.battlefield[index];
        if (attacker.attacked) {
          logMessage("This minion has already attacked.");
          return;
        }
        selectedAttacker = { minion: attacker, index: index };
        logMessage("Selected " + attacker.name + ". Each attack costs " + ATTACK_COST + " mana. Click an enemy minion to attack or the opponent's battlefield (if no enemy minions remain) to attack the hero.");
        updateUI();
      }
      
      function attackHero() {
        if (!selectedAttacker) return;
        if (ai.battlefield.length > 0) {
          logMessage("You must attack enemy minions before targeting the hero.");
          return;
        }
        if (player.currentMana < ATTACK_COST) {
          logMessage("Not enough mana to attack.");
          return;
        }
        player.currentMana -= ATTACK_COST;
        let attacker = selectedAttacker.minion;
        let bonus = 0;
        if (attacker.ability === "shadow" && !attacker.abilityUsed) {
          bonus = attacker.attack;
          attacker.abilityUsed = true;
          logMessage("Phantom's Shadow activated: damage doubled.");
        }
        ai.hero.hp -= (attacker.attack + bonus);
        attacker.attacked = true;
        logMessage("Your " + attacker.name + " attacked the opponent's Villager for " + (attacker.attack + bonus) + " damage.");
        // Recycle attacker if it dies later.
        selectedAttacker = null;
        checkVictory();
        updateUI();
      }
      
      function attackMinion(aiIndex) {
        if (!selectedAttacker) return;
        if (player.currentMana < ATTACK_COST) {
          logMessage("Not enough mana to attack.");
          return;
        }
        player.currentMana -= ATTACK_COST;
        let attacker = selectedAttacker.minion;
        let defender = ai.battlefield[aiIndex];
        let attackerDamage = getEffectiveAttack(attacker, "player");
        let defenderDamage = getEffectiveAttack(defender, "ai");
        let multiplier = 1;
        if (attacker.element && defender.weaknesses && defender.weaknesses.includes(attacker.element)) {
          multiplier = 2;
        } else if (attacker.element && defender.strengths && defender.strengths.includes(attacker.element)) {
          multiplier = 0.5;
        }
        let damageToDefender = Math.floor(attackerDamage * multiplier);
        let damageToAttacker = defenderDamage;
        defender.currentHP -= damageToDefender;
        attacker.currentHP -= damageToAttacker;
        logMessage("Your " + attacker.name + " attacked " + defender.name + " (Damage: " + damageToDefender + " vs " + damageToAttacker + ").");
        attacker.attacked = true;
        if (defender.currentHP <= 0) {
          logMessage("Opponent's " + defender.name + " was destroyed.");
          // Recycle the defeated minion using its stored cardKey.
          ai.discard.push(defender.cardKey || ai.battlefield[aiIndex]);
          ai.battlefield.splice(aiIndex, 1);
        }
        if (attacker.currentHP <= 0) {
          logMessage("Your " + attacker.name + " was destroyed in combat.");
          player.discard.push(attacker.cardKey);
          player.battlefield.splice(selectedAttacker.index, 1);
        }
        selectedAttacker = null;
        checkVictory();
        updateUI();
      }
      
      function activateSelectedAbility() {
        if (!selectedAttacker) {
          logMessage("No minion selected for ability activation.");
          return;
        }
        let attacker = selectedAttacker.minion;
        if (!attacker.ability || attacker.abilityUsed) {
          logMessage("This minion has no available ability.");
          return;
        }
        activateAbility("player", selectedAttacker.index);
        selectedAttacker = null;
        updateUI();
      }
      
      /***** ABILITY FUNCTIONS *****/
      function activateAbility(side, index) {
        let p = (side === "player") ? player : ai;
        let opponent = (side === "player") ? ai : player;
        let minion = p.battlefield[index];
        if (minion.abilityUsed) return;
        switch(minion.ability) {
          case "explode":
            opponent.battlefield.forEach(m => m.currentHP -= 1);
            opponent.hero.hp -= 1;
            logMessage(minion.name + " explodes, dealing 1 damage to all enemy units and hero!");
            p.discard.push(minion.cardKey);
            p.battlefield.splice(index, 1);
            break;
          case "hop":
            drawCard(side);
            logMessage(minion.name + " hops and draws 1 card!");
            minion.abilityUsed = true;
            break;
          case "splash":
            opponent.battlefield.forEach(m => m.currentHP -= 1);
            logMessage(minion.name + " splashes, dealing 1 damage to all enemy minions!");
            minion.abilityUsed = true;
            break;
          case "sweep":
            opponent.battlefield.forEach(m => m.currentHP -= 1);
            logMessage(minion.name + " sweeps, damaging all enemy minions!");
            minion.abilityUsed = true;
            break;
          case "pull":
            if (opponent.battlefield.length > 0) {
              let target = opponent.battlefield[0];
              target.attack = Math.max(0, target.attack - 1);
              logMessage(minion.name + " pulls, reducing " + target.name + "'s attack by 1 for this turn.");
              minion.abilityUsed = true;
            }
            break;
          case "ranged":
            if (opponent.battlefield.length > 0) {
              let target = opponent.battlefield[0];
              target.currentHP -= 2;
              logMessage(minion.name + " uses Ranged attack on " + target.name + " for 2 damage!");
              minion.abilityUsed = true;
              if (target.currentHP <= 0) {
                logMessage(target.name + " was destroyed.");
                opponent.discard.push(target.cardKey);
                opponent.battlefield.shift();
              }
            }
            break;
          case "teleport":
            if (p.battlefield.length > 1) {
              let target = p.battlefield.find((m, i) => i !== index);
              if (target) {
                [p.battlefield[index], p.battlefield[p.battlefield.indexOf(target)]] = [target, minion];
                logMessage(minion.name + " teleports, swapping positions with " + target.name + ".");
                minion.abilityUsed = true;
              }
            }
            break;
          case "jump":
            opponent.hero.hp -= 1;
            opponent.battlefield.forEach(m => m.currentHP -= 1);
            logMessage(minion.name + " jumps, dealing 1 damage to enemy hero and all enemy minions!");
            minion.abilityUsed = true;
            break;
          case "longshot":
            if (opponent.battlefield.length > 0) {
              let target = opponent.battlefield[0];
              target.currentHP -= 2;
              logMessage(minion.name + " fires a long shot at " + target.name + " for 2 damage!");
              minion.abilityUsed = true;
              if (target.currentHP <= 0) {
                logMessage(target.name + " was destroyed.");
                opponent.discard.push(target.cardKey);
                opponent.battlefield.shift();
              }
            }
            break;
          case "copy":
            let friendly = p.battlefield.slice().reverse().find(m => m.ability && m !== minion);
            if (friendly) {
              logMessage(minion.name + " copies " + friendly.name + "'s ability (no additional effect).");
              minion.abilityUsed = true;
            }
            break;
          case "manaBoost":
            logMessage(minion.name + " passively boosts your mana each turn.");
            break;
          case "disrupt":
            if (opponent.hand.length > 0) {
              opponent.hand.splice(Math.floor(Math.random() * opponent.hand.length), 1);
              logMessage(minion.name + " disrupts and forces opponent to discard a card!");
              minion.abilityUsed = true;
            }
            break;
          case "explosiveWither":
            opponent.battlefield.forEach(m => m.currentHP -= 2);
            opponent.hero.hp -= 2;
            logMessage(minion.name + " unleashes Explosive Wither, dealing 2 damage to all enemies!");
            minion.abilityUsed = true;
            break;
          default:
            logMessage("No ability to activate.");
        }
        opponent.battlefield = opponent.battlefield.filter(m => m.currentHP > 0);
      }
      
      /***** BIOME EFFECTS & EFFECTIVE ATTACK *****/
      function getEffectiveAttack(unit, owner) {
        let effective = unit.attack;
        let biome = (owner === "player") ? player.biome : ai.biome;
        if (biome) {
          if (biome.effect === "boost" && unit.element === biome.elementTarget) {
            effective += biome.bonus;
          } else if (biome.effect === "weaken" && unit.element === biome.elementTarget) {
            effective = Math.max(0, effective - biome.penalty);
          }
        }
        return effective;
      }
      
      /***** AI TURN – USE ALL AVAILABLE MANA *****/
      function aiTurn() {
        function aiAction() {
          if (ai.currentMana <= 0) {
            endAITurn();
            return;
          }
          let actionTaken = false;
          // 1. Try to play a card.
          for (let i = 0; i < ai.hand.length; i++) {
            let cardKey = ai.hand[i];
            let cardTemplate = cardTemplates[cardKey];
            if (ai.currentMana >= cardTemplate.cost) {
              ai.currentMana -= cardTemplate.cost;
              ai.hand.splice(i, 1);
              if (cardTemplate.type === "biome") {
                ai.biome = Object.assign({}, cardTemplate);
                logMessage("AI sets its biome to " + cardTemplate.name + ".");
              }
              else if (cardTemplate.type === "minion") {
                let minion = Object.assign({}, cardTemplate);
                minion.cardKey = cardKey;
                minion.currentHP = cardTemplate.hp;
                minion.attacked = false;
                minion.abilityUsed = false;
                ai.battlefield.push(minion);
                logMessage("AI summoned a " + minion.name + ".");
              } else if (cardTemplate.type === "spell") {
                if (cardTemplate.effect === "draw2") {
                  drawCard("ai");
                  drawCard("ai");
                  logMessage("AI cast Reinforcement.");
                } else if (cardTemplate.effect === "lightning") {
                  if (player.battlefield.length > 0) {
                    player.battlefield[0].currentHP -= cardTemplate.damage;
                    logMessage("AI cast Lightning on your " + player.battlefield[0].name + " for " + cardTemplate.damage + " damage.");
                    if (player.battlefield[0].currentHP <= 0) {
                      logMessage("Your " + player.battlefield[0].name + " was destroyed.");
                      player.discard.push(player.battlefield[0].cardKey);
                      player.battlefield.shift();
                    }
                  } else {
                    player.hero.hp -= cardTemplate.damage;
                    logMessage("AI cast Lightning on your Villager for " + cardTemplate.damage + " damage.");
                  }
                } else if (cardTemplate.effect === "heal") {
                  ai.hero.hp += cardTemplate.amount;
                  logMessage("AI cast Heal and restored " + cardTemplate.amount + " HP to its Villager.");
                }
              }
              // Recycle played card.
              ai.discard.push(cardKey);
              actionTaken = true;
              break;
            }
          }
          // 2. If no card was played, try to attack.
          if (!actionTaken) {
            for (let i = 0; i < ai.battlefield.length; i++) {
              let minion = ai.battlefield[i];
              if (!minion.attacked && ai.currentMana >= ATTACK_COST) {
                ai.currentMana -= ATTACK_COST;
                if (player.battlefield.length > 0) {
                  let defender = player.battlefield[0];
                  let attackerDamage = getEffectiveAttack(minion, "ai");
                  let defenderDamage = getEffectiveAttack(defender, "player");
                  let multiplier = 1;
                  if (minion.element && defender.weaknesses && defender.weaknesses.includes(minion.element)) {
                    multiplier = 2;
                  } else if (minion.element && defender.strengths && defender.strengths.includes(minion.element)) {
                    multiplier = 0.5;
                  }
                  let damageToDefender = Math.floor(attackerDamage * multiplier);
                  let damageToAttacker = defenderDamage;
                  defender.currentHP -= damageToDefender;
                  minion.currentHP -= damageToAttacker;
                  logMessage("AI's " + minion.name + " attacked your " + defender.name + " (Damage: " + damageToDefender + " vs " + damageToAttacker + ").");
                  if (defender.currentHP <= 0) {
                    logMessage("Your " + defender.name + " was destroyed.");
                    player.discard.push(defender.cardKey);
                    player.battlefield.shift();
                  }
                } else {
                  let dmg = getEffectiveAttack(minion, "ai");
                  player.hero.hp -= dmg;
                  logMessage("AI's " + minion.name + " attacked your Villager for " + dmg + " damage.");
                }
                minion.attacked = true;
                actionTaken = true;
                break;
              }
            }
          }
          // 3. If no card or attack, try to use an ability.
          if (!actionTaken) {
            for (let i = 0; i < ai.battlefield.length; i++) {
              let minion = ai.battlefield[i];
              if (minion.ability && !minion.abilityUsed) {
                activateAbility("ai", i);
                actionTaken = true;
                break;
              }
            }
          }
          if (ai.currentMana > 0) {
            setTimeout(aiAction, 800);
          } else {
            endAITurn();
          }
        }
        aiAction();
      }
      
      function endAITurn() {
        checkVictory();
        ai.battlefield.forEach(m => { m.attacked = false; m.abilityUsed = false; });
        player.battlefield.forEach(m => { m.attacked = false; m.abilityUsed = false; });
        currentTurn = "player";
        // Ramp player's mana.
        player.maxMana = Math.min(player.maxMana + 1, MAX_MANA);
        if (player.battlefield.some(m => m.name === "Cat")) {
          player.maxMana = Math.min(player.maxMana + 1, MAX_MANA);
        }
        player.currentMana = player.maxMana;
        drawCard("player");
        logMessage("Your turn begins.");
        updateUI();
      }
      
      /***** VICTORY CHECK *****/
      function checkVictory() {
        if (player.hero.hp <= 0) {
          logMessage("Your Villager has been defeated. You lose!");
          currentTurn = "gameover";
        }
        if (ai.hero.hp <= 0) {
          logMessage("Opponent's Villager has been defeated. You win!");
          currentTurn = "gameover";
        }
      }
      
      /***** UI UPDATES *****/
      function updateUI() {
        document.getElementById("playerHeroHP").innerText = player.hero.hp;
        document.getElementById("opponentHeroHP").innerText = ai.hero.hp;
        document.getElementById("playerMana").innerText = player.currentMana + " / " + player.maxMana;
        document.getElementById("opponentMana").innerText = ai.currentMana + " / " + ai.maxMana;
        
        document.getElementById("playerBiome").innerText = player.biome ? player.biome.name : "None";
        document.getElementById("opponentBiome").innerText = ai.biome ? ai.biome.name : "None";
        
        let playerBF = document.getElementById("playerBattlefield");
        playerBF.innerHTML = "";
        player.battlefield.forEach((minion, index) => {
          let effectiveAttack = getEffectiveAttack(minion, "player");
          let div = document.createElement("div");
          div.className = "minion" + (selectedAttacker && selectedAttacker.index === index ? " selected" : "");
          div.innerText = minion.name + "\n" + effectiveAttack + "/" + minion.currentHP;
          div.onclick = () => selectAttacker(index);
          playerBF.appendChild(div);
        });
        
        let opponentBF = document.getElementById("opponentBattlefield");
        opponentBF.innerHTML = "";
        ai.battlefield.forEach((minion, index) => {
          let effectiveAttack = getEffectiveAttack(minion, "ai");
          let div = document.createElement("div");
          div.className = "minion";
          div.innerText = minion.name + "\n" + effectiveAttack + "/" + minion.currentHP;
          div.onclick = () => { if (selectedAttacker) attackMinion(index); };
          opponentBF.appendChild(div);
        });
        
        let handContainer = document.getElementById("handContainer");
        handContainer.innerHTML = "";
        player.hand.forEach((cardKey, index) => {
          let card = cardTemplates[cardKey];
          let div = document.createElement("div");
          div.className = "card";
          div.innerText = card.name + "\nCost: " + card.cost;
          div.onclick = () => playCard(index);
          handContainer.appendChild(div);
        });
        
        let opponentHand = document.getElementById("opponentHand");
        opponentHand.innerHTML = "";
        ai.hand.forEach((cardKey, index) => {
          let card = cardTemplates[cardKey];
          let div = document.createElement("div");
          div.className = "card";
          div.innerText = card.name + "\nCost: " + card.cost;
          opponentHand.appendChild(div);
        });
        
        document.getElementById("activateAbilityButton").style.display = (selectedAttacker && selectedAttacker.minion.ability && !selectedAttacker.minion.abilityUsed) ? "inline-block" : "none";
      }
      
      function logMessage(msg) {
        document.getElementById("message").innerText = msg;
      }
      
      // If opponent battlefield is clicked (and no enemy minions exist), treat as an attack on the hero.
      document.getElementById("opponentBattlefield").onclick = function(e) {
        if (ai.battlefield.length === 0 && selectedAttacker) {
          attackHero();
        }
      };
      
      window.onload = function() {
        populateAvailableCards();
        populateSelectedDeck();
        updateDeckCount();
      };
    </script>
  </body>
</html>
