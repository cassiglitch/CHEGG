<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>
      Custom Card Game – Hero, Deck, Mana, AI, Recycling & Upgrade</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        background: #f4f4f4;
        margin: 0;
        padding: 10px;
      }
      h1, h2 {
        text-align: center;
      }
      #gameContainer, #deckBuilderContainer {
        max-width: 1200px;
        margin: 0 auto;
        background: #fff;
        padding: 10px;
        box-shadow: 0 0 10px rgba(0,0,0,0.2);
      }
      .section { margin-bottom: 15px; }
      .area {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 5px;
        border: 1px solid #ccc;
        background: #e9e9e9;
        margin-bottom: 5px;
      }
      .battlefield, .hand, .biomeZone, .deckArea {
        min-height: 80px;
        padding: 5px;
        border: 1px dashed #888;
        background: #fff;
        margin: 5px 0;
      }
      .card, .minion, .deckCard {
        display: inline-block;
        border: 1px solid #333;
        border-radius: 4px;
        background: #fafafa;
        padding: 5px;
        margin: 5px;
        cursor: pointer;
        white-space: pre-line;
      }
      .selected { border: 2px solid #f80; background: #fffae6; }
      #message {
        margin-top: 10px;
        padding: 5px;
        background: #eef;
        border: 1px solid #99f;
      }
      #controls { text-align: center; margin-top: 10px; }
      button { margin: 5px; padding: 8px 16px; font-size: 16px; }
      .info { font-size: 18px; }
      .biomeZone { font-style: italic; text-align: center; }
      /* Deck builder styles */
      #deckBuilderContainer { margin-bottom: 20px; }
      #availableCards, #selectedDeck { border: 1px solid #888; padding: 5px; min-height: 120px; background: #fff; margin: 5px 0; }
      .deckCard { cursor: pointer; }
      /* Hero selection styles */
      #heroSelection { text-align: center; margin-bottom: 15px; }
      .heroOption { display: inline-block; border: 1px solid #333; border-radius: 4px; padding: 8px 12px; margin: 5px; cursor: pointer; background: #fafafa; }
    </style>
  </head>
  <body>
    <!-- DECK BUILDER & HERO SELECTION VIEW -->
    <div id="deckBuilderContainer">
      <h1>Deck Builder & Hero Selection</h1>
      <div id="heroSelection">
        <h2>Select Your Hero</h2>
        <!-- Four hero options -->
        <div class="heroOption" onclick="selectHero('Villager')">
          <strong>Guardian</strong><br>30 HP, No Passive
        </div>
        <div class="heroOption" onclick="selectHero('Druid')">
          <strong>Druid</strong><br>20 HP, Starts with Forest
        </div>
        <div class="heroOption" onclick="selectHero('GuardianPassive')">
          <strong>Guardian</strong><br>20 HP, Units take 1 less targeted damage, but Hero takes 1 more
        </div>
        <div class="heroOption" onclick="selectHero('Sandcrawler')">
          <strong>Sandcrawler</strong><br>20 HP, Starts with Desert
        </div>
      </div>
      <p id="selectedHeroDisplay" style="text-align:center;">Selected Hero: None</p>
      <p>Select up to 15 cards for your deck. (Biome cards do not count toward your 5‑card hand minimum.)</p>
      <div class="section">
        <h2>Available Cards</h2>
        <div id="availableCards" class="deckArea"></div>
      </div>
      <div class="section">
        <h2>Your Deck (<span id="deckCount">0</span>/15)</h2>
        <div id="selectedDeck" class="deckArea"></div>
      </div>
      <div class="section" style="text-align:center;">
        <button onclick="saveDeck()">Save Deck</button>
        <input type="file" id="loadDeckFile" accept=".json" onchange="loadDeck(event)">
        <button onclick="startGame()">Start Game</button>
      </div>
    </div>

    <!-- GAME VIEW -->
    <div id="gameContainer" style="display:none;">
      <h1>Custom Card Game – Deck, Mana, AI, Recycling & Upgrade</h1>
      <!-- Opponent Info -->
      <div class="section">
        <div class="area">
          <div>
            <strong>Opponent Hero</strong><br>
            <span id="opponentHeroHP" class="info"></span>
          </div>
          <div>
            <strong>Opponent Mana</strong><br>
            <span id="opponentMana" class="info"></span>
          </div>
        </div>
        <div class="area">
          <div style="width:32%;">
            <strong>Opponent Biome</strong>
            <div id="opponentBiome" class="biomeZone"></div>
          </div>
          <div style="width:32%;">
            <strong>Opponent Battlefield</strong>
            <div id="opponentBattlefield" class="battlefield"></div>
          </div>
          <div style="width:32%;">
            <strong>Opponent Hand</strong>
            <div id="opponentHand" class="hand"></div>
          </div>
        </div>
      </div>
      
      <!-- Player Info -->
      <div class="section">
        <div class="area">
          <div>
            <strong>Your Hero</strong><br>
            <span id="playerHeroHP" class="info"></span>
          </div>
          <div>
            <strong>Your Mana</strong><br>
            <span id="playerMana" class="info"></span>
          </div>
        </div>
        <div class="area">
          <div style="width:32%;">
            <strong>Your Biome</strong>
            <div id="playerBiome" class="biomeZone"></div>
          </div>
          <div style="width:32%;">
            <strong>Your Battlefield</strong>
            <div id="playerBattlefield" class="battlefield"></div>
          </div>
          <div style="width:32%;">
            <strong>Your Hand</strong>
            <div id="handContainer" class="hand"></div>
          </div>
        </div>
      </div>
      
      <!-- Controls -->
      <div id="controls" class="section">
        <button onclick="endTurn()" id="endTurnButton">End Turn</button>
        <button onclick="activateSelectedAbility()" id="activateAbilityButton" style="display:none;">Activate Ability</button>
        <button onclick="upgradeUnits()" id="upgradeButton" style="display:none;">Upgrade Units</button>
        <button onclick="resetGame()">Reset Game</button>
      </div>
      
      <!-- Message Log -->
      <div id="message" class="section">Welcome to the game!</div>
    </div>
    
    <script>
      /***** GAME CONFIGURATION *****/
      const MAX_MANA = 6;
      const STARTING_HP = 20;
      const ATTACK_COST = 1; // Each attack costs 1 mana
      const MAX_MINIONS = 3; // Max minions on battlefield per side
      const MIN_HAND_SIZE = 5; // Minimum non-biome cards in hand

      // Hero templates
      const heroTemplates = {
        "Villager": { name: "Guardian", hp: 30, passive: null },
        "Druid": { name: "Druid", hp: 20, passive: "forest" },
        "GuardianPassive": { name: "Guardian", hp: 20, passive: "guardian" },
        "Sandcrawler": { name: "Sandcrawler", hp: 20, passive: "desert" }
      };

      // Card templates (custom names and new spells/units)
      const cardTemplates = {
        "Villager": { type: "hero", name: "Guardian", cost: 0, attack: 0, hp: STARTING_HP },
        "Zombie": { type: "minion", name: "Rotter", cost: 1, attack: 1, hp: 1, element: "undead", strengths: [], weaknesses: ["fire"] },
        "Creeper": { type: "minion", name: "Boomer", cost: 1, attack: 1, hp: 1, element: "undead", strengths: [], weaknesses: ["water"], ability: "explode" },
        "Pig": { type: "minion", name: "Oink", cost: 1, attack: 0, hp: 1, element: "beast", strengths: [], weaknesses: [], ability: "support" },
        "Rabbit": { type: "minion", name: "Bunny", cost: 2, attack: 1, hp: 1, element: "beast", strengths: [], weaknesses: [], ability: "hop" },
        "PufferFish": { type: "minion", name: "Spiky", cost: 2, attack: 1, hp: 1, element: "water", strengths: ["fire"], weaknesses: ["electric"], ability: "splash" },
        "IronGolem": { type: "minion", name: "Guardian Golem", cost: 2, attack: 2, hp: 3, element: "earth", strengths: ["undead"], weaknesses: ["water"], ability: "sweep" },
        "Frog": { type: "minion", name: "Hopper", cost: 2, attack: 0, hp: 2, element: "water", strengths: [], weaknesses: ["fire"], ability: "pull" },
        "Skeleton": { type: "minion", name: "Bone Knight", cost: 3, attack: 3, hp: 2, element: "undead", strengths: [], weaknesses: ["fire"] },
        "Blaze": { type: "minion", name: "Flare", cost: 3, attack: 3, hp: 2, element: "fire", strengths: ["undead"], weaknesses: ["water"], ability: "ranged" },
        "Phantom": { type: "minion", name: "Wraith", cost: 3, attack: 2, hp: 1, element: "air", strengths: [], weaknesses: ["earth"], ability: "shadow" },
        "Enderman": { type: "minion", name: "Shadow", cost: 4, attack: 3, hp: 2, element: "dark", strengths: [], weaknesses: ["light"], ability: "teleport" },
        "Slime": { type: "minion", name: "Goo", cost: 4, attack: 2, hp: 3, element: "earth", strengths: [], weaknesses: ["fire"], ability: "jump" },
        "ShulkerBox": { type: "minion", name: "Pack", cost: 4, attack: 1, hp: 4, element: "metal", strengths: [], weaknesses: ["earth"], ability: "longshot" },
        "Parrot": { type: "minion", name: "Chirper", cost: 5, attack: 3, hp: 2, element: "air", strengths: [], weaknesses: ["electric"], ability: "copy" },
        "Cat": { type: "minion", name: "Feline", cost: 5, attack: 0, hp: 2, element: "beast", strengths: [], weaknesses: [], ability: "manaBoost" },
        "Sniffer": { type: "minion", name: "Tracker", cost: 5, attack: 2, hp: 2, element: "beast", strengths: [], weaknesses: [], ability: "disrupt" },
        "Wither": { type: "minion", name: "Decay", cost: 6, attack: 4, hp: 3, element: "undead", strengths: ["beast"], weaknesses: ["fire"], ability: "explosiveWither" },
        "Dragon": { type: "minion", name: "Dragon", cost: 7, attack: 6, hp: 6, element: "dragon", strengths: ["air"], weaknesses: ["undead"], ability: "aoe" },
        "Reinforcement": { type: "spell", name: "Reinforcement", cost: 2, effect: "draw2" },
        "Lightning": { type: "spell", name: "Lightning Bolt", cost: 3, effect: "lightning", damage: 3 },
        "Heal": { type: "spell", name: "Heal", cost: 3, effect: "heal", amount: 3 },
        "Barrier": { type: "spell", name: "Barrier", cost: 6, effect: "barrier" },
        "Forest": { type: "biome", name: "Enchanted Forest", cost: 3, effect: "boost", elementTarget: "beast", bonus: 1 },
        "Desert": { type: "biome", name: "Scorched Desert", cost: 3, effect: "weaken", elementTarget: "water", penalty: 1 }
      };

      /***** GAME STATE *****/
      let currentTurn = "player"; // "player" or "ai"
      let turnNumber = 1;
      let selectedHero = null; // Hero key from heroTemplates

      let player = {
        hero: null,
        deck: [], // Loaded via deck builder
        hand: [],
        battlefield: [],
        biome: null,
        discard: [],
        currentMana: 0,
        maxMana: 0
      };
      let ai = {
        hero: null,
        deck: [], // Default deck for AI
        hand: [],
        battlefield: [],
        biome: null,
        discard: [],
        currentMana: 0,
        maxMana: 0
      };

      // For selecting a minion for attack/ability.
      let selectedAttacker = null;

      /***** HERO SELECTION *****/
      function selectHero(heroKey) {
        selectedHero = heroKey;
        document.getElementById("selectedHeroDisplay").innerText = "Selected Hero: " + heroTemplates[heroKey].name;
      }

      /***** DECK BUILDER FUNCTIONS *****/
      const availableCardKeys = Object.keys(cardTemplates).filter(key => {
        let type = cardTemplates[key].type;
        return (type === "minion" || type === "spell" || type === "biome");
      });

      function populateAvailableCards() {
        let container = document.getElementById("availableCards");
        container.innerHTML = "";
        availableCardKeys.forEach(key => {
          let card = cardTemplates[key];
          let div = document.createElement("div");
          div.className = "deckCard";
          div.innerText = card.name + "\nCost: " + card.cost;
          div.onclick = () => addCardToDeck(key);
          container.appendChild(div);
        });
      }

      function addCardToDeck(cardKey) {
        if (player.deck.length >= 15) {
          alert("Deck limit reached (15 cards).");
          return;
        }
        player.deck.push(cardKey);
        updateDeckCount();
        populateSelectedDeck();
      }

      function updateDeckCount() {
        document.getElementById("deckCount").innerText = player.deck.length;
      }

      function populateSelectedDeck() {
        let container = document.getElementById("selectedDeck");
        container.innerHTML = "";
        player.deck.forEach((cardKey, idx) => {
          let card = cardTemplates[cardKey];
          let div = document.createElement("div");
          div.className = "deckCard";
          div.innerText = card.name + "\nCost: " + card.cost;
          div.onclick = () => { 
            player.deck.splice(idx, 1);
            updateDeckCount();
            populateSelectedDeck();
          };
          container.appendChild(div);
        });
      }

      function saveDeck() {
        if (player.deck.length === 0) {
          alert("Your deck is empty!");
          return;
        }
        const data = JSON.stringify(player.deck);
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = "deck.json";
        a.click();
        URL.revokeObjectURL(url);
      }

      function loadDeck(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const loadedDeck = JSON.parse(e.target.result);
            if (Array.isArray(loadedDeck) && loadedDeck.length <= 15) {
              player.deck = loadedDeck;
              updateDeckCount();
              populateSelectedDeck();
            } else {
              alert("Invalid deck file.");
            }
          } catch (err) {
            alert("Error reading deck file.");
          }
        };
        reader.readAsText(file);
      }

      /***** DRAW CARD (with Recycling & Minimum Hand) *****/
      function drawCard(side) {
        let p = (side === "player") ? player : ai;
        if (p.deck.length === 0 && p.discard.length > 0) {
          logMessage(side + "'s deck is empty. Recycling discard pile.");
          p.deck = shuffleArray(p.discard);
          p.discard = [];
        }
        if (p.deck.length > 0) {
          let cardKey = p.deck.shift();
          p.hand.push(cardKey);
          logMessage(side + " drew: " + cardTemplates[cardKey].name);
        } else {
          logMessage(side + " has no cards left to draw!");
        }
      }

      // Ensure hand (excluding biome cards) has at least 5 cards.
      function ensureMinimumHand(side) {
        let p = (side === "player") ? player : ai;
        let nonBiomeCount = p.hand.filter(key => cardTemplates[key].type !== "biome").length;
        while (nonBiomeCount < MIN_HAND_SIZE) {
          drawCard(side);
          nonBiomeCount = p.hand.filter(key => cardTemplates[key].type !== "biome").length;
          if (p.deck.length === 0 && p.discard.length === 0) break;
        }
      }

      /***** GAME FUNCTIONS *****/
      function startGame() {
        if (player.deck.length === 0) {
          alert("Please build a deck (up to 15 cards) before starting the game.");
          return;
        }
        if (!selectedHero) {
          alert("Please select a hero before starting.");
          return;
        }
        document.getElementById("deckBuilderContainer").style.display = "none";
        document.getElementById("gameContainer").style.display = "block";
        // Shuffle player's deck.
        player.deck = shuffleArray(player.deck);
        // Build AI default deck.
        ai.deck = buildDefaultAIDeck();
        ai.deck = shuffleArray(ai.deck);
        initGame();
      }

      function shuffleArray(array) {
        return array.sort(() => Math.random() - 0.5);
      }

      function buildDefaultAIDeck() {
        const defaultKeys = ["Zombie", "Skeleton", "Blaze", "Reinforcement", "Lightning", "Forest", "Cat", "Rabbit", "Pig", "Enderman", "Heal", "Desert", "Frog", "Creeper", "Sniffer"];
        return defaultKeys;
      }

      /***** GAME STATE INITIALIZATION *****/
      function initGame() {
        turnNumber = 1;
        currentTurn = "player";
        selectedAttacker = null;
        player.biome = null;
        ai.biome = null;
        player.discard = [];
        ai.discard = [];

        // Set player's Hero based on selectedHero.
        let heroTemplate = heroTemplates[selectedHero];
        player.hero = { name: heroTemplate.name, hp: heroTemplate.hp, attack: 0, barrierTurns: 0, passive: heroTemplate.passive };
        // For hero passives that set starting biome.
        if (heroTemplate.passive === "forest") {
          player.biome = Object.assign({}, cardTemplates["Forest"]);
        } else if (heroTemplate.passive === "desert") {
          player.biome = Object.assign({}, cardTemplates["Desert"]);
        }
        // AI always uses default hero (Villager equivalent)
        ai.hero = { name: "Opponent Guardian", hp: STARTING_HP, attack: 0, barrierTurns: 0, passive: null };

        // Clear hands and battlefields.
        player.hand = [];
        ai.hand = [];
        player.battlefield = [];
        ai.battlefield = [];

        // For starting hand, draw 5 random cards from player's deck.
        for (let i = 0; i < 5; i++) {
          if (player.deck.length > 0) {
            let randIndex = Math.floor(Math.random() * player.deck.length);
            let cardKey = player.deck.splice(randIndex, 1)[0];
            player.hand.push(cardKey);
          }
        }
        // For AI, draw the first 5 cards.
        for (let i = 0; i < 5; i++) {
          if (ai.deck.length > 0) {
            let cardKey = ai.deck.shift();
            ai.hand.push(cardKey);
          }
        }

        // Initialize mana (starting at 1).
        player.maxMana = 1;
        player.currentMana = 1;
        ai.maxMana = 1;
        ai.currentMana = 1;

        updateUI();
        logMessage("Game started! Your turn begins.");
        startTurn("player");
      }

      /***** TURN MANAGEMENT *****/
      function startTurn(side) {
        currentTurn = side;
        if (side === "player") {
          if (turnNumber > 1) {
            player.maxMana = Math.min(player.maxMana + 1, MAX_MANA);
            if (player.battlefield.some(m => m.name === "Cat")) {
              player.maxMana = Math.min(player.maxMana + 1, MAX_MANA);
            }
          }
          turnNumber++;
          player.currentMana = player.maxMana;
          ensureMinimumHand("player");
          logMessage("Your turn. You have " + player.currentMana + " mana.");
          updateUI();
        } else {
          ai.maxMana = Math.min(ai.maxMana + 1, MAX_MANA);
          ai.currentMana = ai.maxMana;
          ensureMinimumHand("ai");
          logMessage("AI turn. AI has " + ai.currentMana + " mana.");
          updateUI();
          setTimeout(aiTurn, 1000);
        }
      }

      function endTurn() {
        if (currentTurn !== "player") return;
        logMessage("Ending your turn.");
        player.battlefield.forEach(m => { m.attacked = false; m.abilityUsed = false; });
        currentTurn = "ai";
        drawCard("ai");
           ai.maxMana = Math.min(ai.maxMana + 1, MAX_MANA);
          ai.currentMana = ai.maxMana;
        updateUI();
        setTimeout(aiTurn, 1000);
      }

      /***** PLAYER ACTIONS *****/
      function playCard(index) {
        if (currentTurn !== "player") return;
        let cardKey = player.hand[index];
        let cardTemplate = cardTemplates[cardKey];
        if (player.currentMana < cardTemplate.cost) {
          logMessage("Not enough mana to play " + cardTemplate.name + ".");
          return;
        }
        // For minions, check battlefield limit.
        if (cardTemplate.type === "minion" && player.battlefield.length >= MAX_MINIONS) {
          logMessage("Maximum of 3 minions allowed on the battlefield. Cannot play " + cardTemplate.name + ".");
          return;
        }
        player.currentMana -= cardTemplate.cost;
        player.hand.splice(index, 1);
        if (cardTemplate.type === "biome") {
          player.biome = Object.assign({}, cardTemplate);
          logMessage("You set your biome to " + cardTemplate.name + ".");
          // Biome cards always remain in hand.
          player.hand.push(cardKey);
        } else if (cardTemplate.type === "minion") {
          let minion = Object.assign({}, cardTemplate);
          minion.cardKey = cardKey;
          minion.currentHP = cardTemplate.hp;
          minion.attacked = false;
          minion.abilityUsed = false;
          player.battlefield.push(minion);
          if (minion.ability === "support") {
            drawCard("player");
            logMessage("Oink's support activated: you draw 1 card.");
          }
          logMessage("You summoned " + minion.name + ".");
        } else if (cardTemplate.type === "spell") {
          if (cardTemplate.effect === "draw2") {
            drawCard("player");
            drawCard("player");
            logMessage("You cast Reinforcement and drew 2 cards.");
          } else if (cardTemplate.effect === "lightning") {
            if (ai.battlefield.length > 0) {
              ai.battlefield[0].currentHP -= cardTemplate.damage;
              logMessage("You cast Lightning Bolt on " + ai.battlefield[0].name + " for " + cardTemplate.damage + " damage.");
              if (ai.battlefield[0].currentHP <= 0) {
                logMessage(ai.battlefield[0].name + " was destroyed.");
                ai.discard.push(ai.battlefield[0].cardKey || "Lightning");
                ai.battlefield.shift();
              }
            } else {
              ai.hero.hp -= cardTemplate.damage;
              logMessage("You cast Lightning Bolt on the opponent's Hero for " + cardTemplate.damage + " damage.");
            }
          } else if (cardTemplate.effect === "heal") {
            player.hero.hp += cardTemplate.amount;
            logMessage("You cast Heal and restored " + cardTemplate.amount + " HP to your Hero.");
          } else if (cardTemplate.effect === "barrier") {
            player.hero.barrierTurns = 2;
            logMessage("You cast Barrier. Your Hero is shielded for 2 turns.");
          }
          player.discard.push(cardKey);
        }
        updateUI();
      }

      function selectAttacker(index) {
        if (currentTurn !== "player") return;
        let attacker = player.battlefield[index];
        if (attacker.attacked) {
          logMessage("This minion has already attacked.");
          return;
        }
        selectedAttacker = { minion: attacker, index: index };
        logMessage("Selected " + attacker.name + ". Each attack costs " + ATTACK_COST + " mana. Click an enemy minion to attack or the opponent's battlefield (if no enemy minions remain) to attack the Hero.");
        updateUI();
      }

      function attackHero() {
        if (!selectedAttacker) return;
        if (ai.battlefield.length > 0) {
          logMessage("You must attack enemy minions before targeting the Hero.");
          return;
        }
        if (player.currentMana < ATTACK_COST) {
          logMessage("Not enough mana to attack.");
          return;
        }
        // If opponent Hero has Barrier active, the attack does nothing (but still costs mana).
        if (ai.hero.barrierTurns > 0) {
          player.currentMana -= ATTACK_COST;
          logMessage("Opponent's Barrier prevented damage. Your attack cost " + ATTACK_COST + " mana.");
          selectedAttacker.minion.attacked = true;
          selectedAttacker = null;
          updateUI();
          return;
        }
        player.currentMana -= ATTACK_COST;
        let attacker = selectedAttacker.minion;
        let bonus = 0;
        if (attacker.ability === "shadow" && !attacker.abilityUsed) {
          bonus = attacker.attack;
          attacker.abilityUsed = true;
          logMessage("Wraith's Shadow activated: damage doubled.");
        }
        let totalDamage = attacker.attack + bonus;
        // If totalDamage is 0, reduce opponent Hero's attack instead.
        if (totalDamage === 0) {
          ai.hero.attack = Math.max(0, ai.hero.attack - 1);
          logMessage("Your attack did 0 damage. Opponent Hero's attack reduced by 1.");
        } else {
          // For Guardian passive, Hero takes 1 extra damage.
          if (player.hero.passive === "guardian") totalDamage += 1;
          ai.hero.hp -= totalDamage;
          logMessage("Your " + attacker.name + " attacked the opponent's Hero for " + totalDamage + " damage.");
        }
        attacker.attacked = true;
        selectedAttacker = null;
        checkVictory();
        updateUI();
      }

      function attackMinion(aiIndex) {
        if (!selectedAttacker) return;
        if (player.currentMana < ATTACK_COST) {
          logMessage("Not enough mana to attack.");
          return;
        }
        player.currentMana -= ATTACK_COST;
        let attacker = selectedAttacker.minion;
        let defender = ai.battlefield[aiIndex];
        let attackerDamage = getEffectiveAttack(attacker, "player");
        let defenderDamage = getEffectiveAttack(defender, "ai");
        let multiplier = 1;
        if (attacker.element && defender.weaknesses && defender.weaknesses.includes(attacker.element)) {
          multiplier = 2;
        } else if (attacker.element && defender.strengths && defender.strengths.includes(attacker.element)) {
          multiplier = 0.5;
        }
        let damageToDefender = Math.floor(attackerDamage * multiplier);
        let damageToAttacker = defenderDamage;
        // If damage would be 0 and no Barrier, reduce defender's attack instead.
        if (damageToDefender === 0) {
          if (ai.hero.barrierTurns > 0) {
            logMessage("Opponent's Barrier prevented damage.");
          } else {
            defender.attack = Math.max(0, defender.attack - 1);
            logMessage("Your attack did 0 damage. " + defender.name + "'s attack reduced by 1.");
          }
        } else {
          defender.currentHP -= damageToDefender;
          logMessage("Your " + attacker.name + " attacked " + defender.name + " (Damage: " + damageToDefender + " vs " + damageToAttacker + ").");
        }
        attacker.currentHP -= damageToAttacker;
        attacker.attacked = true;
        if (defender.currentHP <= 0) {
          logMessage("Opponent's " + defender.name + " was destroyed.");
          ai.discard.push(defender.cardKey);
          ai.battlefield.splice(aiIndex, 1);
        }
        if (attacker.currentHP <= 0) {
          logMessage("Your " + attacker.name + " was destroyed in combat.");
          player.discard.push(attacker.cardKey);
          player.battlefield.splice(selectedAttacker.index, 1);
        }
        selectedAttacker = null;
        checkVictory();
        updateUI();
      }

      function activateSelectedAbility() {
        if (!selectedAttacker) {
          logMessage("No minion selected for ability activation.");
          return;
        }
        let attacker = selectedAttacker.minion;
        if (!attacker.ability || attacker.abilityUsed) {
          logMessage("This minion has no available ability.");
          return;
        }
        activateAbility("player", selectedAttacker.index);
        selectedAttacker = null;
        updateUI();
      }

      /***** UPGRADE (COMBINE) UNITS *****/
      function upgradeUnits() {
        // Check for any unit type with 2 or more on player's battlefield.
        let counts = {};
        player.battlefield.forEach((unit) => {
          counts[unit.name] = (counts[unit.name] || 0) + 1;
        });
        let upgradable = Object.keys(counts).filter(name => counts[name] >= 2);
        if (upgradable.length === 0) {
          logMessage("No units available for upgrade.");
          return;
        }
        // Prompt the player to choose one of the available unit types.
        let choice = prompt("Enter the name of the unit type to upgrade from: " + upgradable.join(", "));
        if (!choice || !upgradable.includes(choice)) {
          logMessage("Invalid choice.");
          return;
        }
        // Combine all units of that type.
        let units = player.battlefield.filter(u => u.name === choice || u.name === choice + " (Upgraded)");
        if (units.length < 2) {
          logMessage("Not enough units to upgrade.");
          return;
        }
        let totalAttack = units.reduce((sum, u) => sum + u.attack, 0);
        let totalHP = units.reduce((sum, u) => sum + u.currentHP, 0);
        // Add bonus: +1 to attack and HP.
        totalAttack += 1;
        totalHP += 1;
        // Remove these units from battlefield.
        player.battlefield = player.battlefield.filter(u => u.name !== choice && u.name !== (choice + " (Upgraded)"));
        // Add the new upgraded unit.
        let upgradedUnit = Object.assign({}, cardTemplates[units[0].cardKey || choice]);
        upgradedUnit.attack = totalAttack;
        upgradedUnit.hp = totalHP;
        upgradedUnit.currentHP = totalHP;
        upgradedUnit.name = choice + " (Upgraded)";
        upgradedUnit.attacked = false;
        upgradedUnit.abilityUsed = false;
        player.battlefield.push(upgradedUnit);
        logMessage("Upgraded " + units.length + " " + choice + "(s) into one " + upgradedUnit.name + " with " + totalAttack + " attack and " + totalHP + " HP.");
        updateUI();
      }

      /***** ABILITY FUNCTIONS *****/
      function activateAbility(side, index) {
        let p = (side === "player") ? player : ai;
        let opponent = (side === "player") ? ai : player;
        let minion = p.battlefield[index];
        if (minion.abilityUsed) return;
        switch(minion.ability) {
          case "explode":
            opponent.battlefield.forEach(m => m.currentHP -= 1);
            opponent.hero.hp -= 1;
            logMessage(minion.name + " explodes, dealing 1 damage to all enemy units and Hero!");
            p.discard.push(minion.cardKey);
            p.battlefield.splice(index, 1);
            break;
          case "hop":
            drawCard(side);
            logMessage(minion.name + " hops and draws 1 card!");
            minion.abilityUsed = true;
            break;
          case "splash":
            opponent.battlefield.forEach(m => m.currentHP -= 1);
            logMessage(minion.name + " splashes, dealing 1 damage to all enemy minions!");
            minion.abilityUsed = true;
            break;
          case "sweep":
            opponent.battlefield.forEach(m => m.currentHP -= 1);
            logMessage(minion.name + " sweeps, damaging all enemy minions!");
            minion.abilityUsed = true;
            break;
          case "pull":
            if (opponent.battlefield.length > 0) {
              let target = opponent.battlefield[0];
              target.attack = Math.max(0, target.attack - 1);
              logMessage(minion.name + " pulls, reducing " + target.name + "'s attack by 1 for this turn.");
              minion.abilityUsed = true;
            }
            break;
          case "ranged":
            if (opponent.battlefield.length > 0) {
              let target = opponent.battlefield[0];
              target.currentHP -= 2;
              logMessage(minion.name + " uses Ranged attack on " + target.name + " for 2 damage!");
              minion.abilityUsed = true;
              if (target.currentHP <= 0) {
                logMessage(target.name + " was destroyed.");
                opponent.discard.push(target.cardKey);
                opponent.battlefield.shift();
              }
            }
            break;
          case "teleport":
            if (p.battlefield.length > 1) {
              let target = p.battlefield.find((m, i) => i !== index);
              if (target) {
                [p.battlefield[index], p.battlefield[p.battlefield.indexOf(target)]] = [target, minion];
                logMessage(minion.name + " teleports, swapping positions with " + target.name + ".");
                minion.abilityUsed = true;
              }
            }
            break;
          case "jump":
            opponent.hero.hp -= 1;
            opponent.battlefield.forEach(m => m.currentHP -= 1);
            logMessage(minion.name + " jumps, dealing 1 damage to enemy Hero and all enemy minions!");
            minion.abilityUsed = true;
            break;
          case "longshot":
            if (opponent.battlefield.length > 0) {
              let target = opponent.battlefield[0];
              target.currentHP -= 2;
              logMessage(minion.name + " fires a long shot at " + target.name + " for 2 damage!");
              minion.abilityUsed = true;
              if (target.currentHP <= 0) {
                logMessage(target.name + " was destroyed.");
                opponent.discard.push(target.cardKey);
                opponent.battlefield.shift();
              }
            }
            break;
          case "copy":
            let friendly = p.battlefield.slice().reverse().find(m => m.ability && m !== minion);
            if (friendly) {
              logMessage(minion.name + " copies " + friendly.name + "'s ability (no additional effect).");
              minion.abilityUsed = true;
            }
            break;
          case "manaBoost":
            logMessage(minion.name + " passively boosts your mana each turn.");
            break;
          case "disrupt":
            if (opponent.hand.length > 0) {
              opponent.hand.splice(Math.floor(Math.random() * opponent.hand.length), 1);
              logMessage(minion.name + " disrupts and forces opponent to discard a card!");
              minion.abilityUsed = true;
            }
            break;
          case "explosiveWither":
            opponent.battlefield.forEach(m => m.currentHP -= 2);
            opponent.hero.hp -= 2;
            logMessage(minion.name + " unleashes Explosive Wither, dealing 2 damage to all enemies!");
            minion.abilityUsed = true;
            break;
          case "aoe":
            opponent.battlefield.forEach(m => m.currentHP -= minion.attack);
            logMessage(minion.name + " unleashes its fiery breath, dealing " + minion.attack + " damage to all enemy minions!");
            minion.abilityUsed = true;
            break;
          default:
            logMessage("No ability to activate.");
        }
        opponent.battlefield = opponent.battlefield.filter(m => m.currentHP > 0);
      }

      /***** BIOME EFFECTS & EFFECTIVE ATTACK *****/
      function getEffectiveAttack(unit, owner) {
        let effective = unit.attack;
        let biome = (owner === "player") ? player.biome : ai.biome;
        if (biome) {
          if (biome.effect === "boost" && unit.element === biome.elementTarget) {
            effective += biome.bonus;
          } else if (biome.effect === "weaken" && unit.element === biome.elementTarget) {
            effective = Math.max(0, effective - biome.penalty);
          }
        }
        return effective;
      }

      /***** AI TURN – USE ALL AVAILABLE MANA *****/
      function aiTurn() {
        function aiAction() {
          // Check if any valid action exists.
          let validActionExists = false;
          for (let i = 0; i < ai.hand.length; i++) {
            let cardTemplate = cardTemplates[ai.hand[i]];
            if (cardTemplate.type === "minion" && ai.battlefield.length >= MAX_MINIONS) continue;
            if (ai.currentMana >= cardTemplate.cost) { validActionExists = true; break; }
          }
          if (!validActionExists) {
            for (let m of ai.battlefield) {
              if (!m.attacked && ai.currentMana >= ATTACK_COST) { validActionExists = true; break; }
            }
          }
          if (!validActionExists) {
            for (let m of ai.battlefield) {
              if (m.ability && !m.abilityUsed) { validActionExists = true; break; }
            }
          }
          if (!validActionExists) { endAITurn(); return; }
          if (ai.currentMana <= 0) { endAITurn(); return; }
          let actionTaken = false;
          // 1. Try to play a card.
          for (let i = 0; i < ai.hand.length; i++) {
            let cardKey = ai.hand[i];
            let cardTemplate = cardTemplates[cardKey];
            if (cardTemplate.type === "minion" && ai.battlefield.length >= MAX_MINIONS) continue;
            if (ai.currentMana >= cardTemplate.cost) {
              ai.currentMana -= cardTemplate.cost;
              ai.hand.splice(i, 1);
              if (cardTemplate.type === "biome") {
                ai.biome = Object.assign({}, cardTemplate);
                logMessage("AI sets its biome to " + cardTemplate.name + ".");
              } else if (cardTemplate.type === "minion") {
                let minion = Object.assign({}, cardTemplate);
                minion.cardKey = cardKey;
                minion.currentHP = cardTemplate.hp;
                minion.attacked = false;
                minion.abilityUsed = false;
                ai.battlefield.push(minion);
                logMessage("AI summoned " + minion.name + ".");
              } else if (cardTemplate.type === "spell") {
                if (cardTemplate.effect === "draw2") {
                  drawCard("ai");
                  drawCard("ai");
                  logMessage("AI cast Reinforcement.");
                } else if (cardTemplate.effect === "lightning") {
                  if (player.battlefield.length > 0) {
                    player.battlefield[0].currentHP -= cardTemplate.damage;
                    logMessage("AI cast Lightning Bolt on your " + player.battlefield[0].name + " for " + cardTemplate.damage + " damage.");
                    if (player.battlefield[0].currentHP <= 0) {
                      logMessage("Your " + player.battlefield[0].name + " was destroyed.");
                      player.discard.push(player.battlefield[0].cardKey);
                      player.battlefield.shift();
                    }
                  } else {
                    player.hero.hp -= cardTemplate.damage;
                    logMessage("AI cast Lightning Bolt on your Hero for " + cardTemplate.damage + " damage.");
                  }
                } else if (cardTemplate.effect === "heal") {
                  ai.hero.hp += cardTemplate.amount;
                  logMessage("AI cast Heal and restored " + cardTemplate.amount + " HP to its Hero.");
                } else if (cardTemplate.effect === "barrier") {
                  ai.hero.barrierTurns = 2;
                  logMessage("AI cast Barrier. Its Hero is shielded for 2 turns.");
                }
              }
              ai.discard.push(cardKey);
              actionTaken = true;
              break;
            }
          }
          // 2. Try to attack.
          if (!actionTaken) {
            for (let i = 0; i < ai.battlefield.length; i++) {
              let minion = ai.battlefield[i];
              if (!minion.attacked && ai.currentMana >= ATTACK_COST) {
                ai.currentMana -= ATTACK_COST;
                if (player.battlefield.length > 0) {
                  let defender = player.battlefield[0];
                  let attackerDamage = getEffectiveAttack(minion, "ai");
                  let defenderDamage = getEffectiveAttack(defender, "player");
                  let multiplier = 1;
                  if (minion.element && defender.weaknesses && defender.weaknesses.includes(minion.element)) {
                    multiplier = 2;
                  } else if (minion.element && defender.strengths && defender.strengths.includes(minion.element)) {
                    multiplier = 0.5;
                  }
                  let damageToDefender = Math.floor(attackerDamage * multiplier);
                  let damageToAttacker = defenderDamage;
                  if (damageToDefender === 0) {
                    if (player.hero.barrierTurns > 0) {
                      logMessage("Your Hero's Barrier prevented damage.");
                    } else {
                      defender.attack = Math.max(0, defender.attack - 1);
                      logMessage("AI's " + minion.name + " attacked but did 0 damage. Your " + defender.name + "'s attack reduced by 1.");
                    }
                  } else {
                    defender.currentHP -= damageToDefender;
                    logMessage("AI's " + minion.name + " attacked your " + defender.name + " (Damage: " + damageToDefender + " vs " + damageToAttacker + ").");
                  }
                  minion.currentHP -= damageToAttacker;
                  if (defender.currentHP <= 0) {
                    logMessage("Your " + defender.name + " was destroyed.");
                    player.discard.push(defender.cardKey);
                    player.battlefield.shift();
                  }
                } else {
                  let dmg = getEffectiveAttack(minion, "ai");
                  if (player.hero.barrierTurns > 0) {
                    logMessage("Your Hero's Barrier prevented damage from AI's " + minion.name + ".");
                  } else {
                    player.hero.hp -= dmg;
                    logMessage("AI's " + minion.name + " attacked your Hero for " + dmg + " damage.");
                  }
                }
                minion.attacked = true;
                actionTaken = true;
                break;
              }
            }
          }
          // 3. Try to use an ability.
          if (!actionTaken) {
            for (let i = 0; i < ai.battlefield.length; i++) {
              let minion = ai.battlefield[i];
              if (minion.ability && !minion.abilityUsed) {
                activateAbility("ai", i);
                actionTaken = true;
                break;
              }
            }
          }
          if (ai.currentMana > 0 && actionTaken) {
            setTimeout(aiAction, 800);
          } else {
            endAITurn();
          }
        }
        aiAction();
      }

      function endAITurn() {
        checkVictory();
        ai.battlefield.forEach(m => { m.attacked = false; m.abilityUsed = false; });
        player.battlefield.forEach(m => { m.attacked = false; m.abilityUsed = false; });
        currentTurn = "player";
        player.maxMana = Math.min(player.maxMana + 1, MAX_MANA);
        if (player.battlefield.some(m => m.name === "Cat")) {
          player.maxMana = Math.min(player.maxMana + 1, MAX_MANA);
        }
        player.currentMana = player.maxMana;
        ensureMinimumHand("player");
        if (player.hero.barrierTurns > 0) player.hero.barrierTurns--;
        if (ai.hero.barrierTurns > 0) ai.hero.barrierTurns--;
        drawCard("player");
        logMessage("Your turn begins.");
        updateUI();
      }

      /***** VICTORY CHECK *****/
      function checkVictory() {
        if (player.hero.hp <= 0) {
          logMessage("Your Hero has been defeated. You lose!");
          currentTurn = "gameover";
        }
        if (ai.hero.hp <= 0) {
          logMessage("Opponent's Hero has been defeated. You win!");
          currentTurn = "gameover";
        }
      }

      /***** UI UPDATES *****/
      function updateUI() {
        document.getElementById("playerHeroHP").innerText = player.hero.hp + (player.hero.barrierTurns > 0 ? " (Barrier: " + player.hero.barrierTurns + " turns)" : "");
        document.getElementById("opponentHeroHP").innerText = ai.hero.hp + (ai.hero.barrierTurns > 0 ? " (Barrier: " + ai.hero.barrierTurns + " turns)" : "");
        document.getElementById("playerMana").innerText = player.currentMana + " / " + player.maxMana;
        document.getElementById("opponentMana").innerText = ai.currentMana + " / " + ai.maxMana;
        document.getElementById("playerBiome").innerText = player.biome ? player.biome.name : "None";
        document.getElementById("opponentBiome").innerText = ai.biome ? ai.biome.name : "None";

        let playerBF = document.getElementById("playerBattlefield");
        playerBF.innerHTML = "";
        player.battlefield.forEach((minion, index) => {
          let effectiveAttack = getEffectiveAttack(minion, "player");
          let div = document.createElement("div");
          div.className = "minion" + (selectedAttacker && selectedAttacker.index === index ? " selected" : "");
          div.innerText = minion.name + "\n" + effectiveAttack + "/" + minion.currentHP;
          div.onclick = () => selectAttacker(index);
          playerBF.appendChild(div);
        });

        let opponentBF = document.getElementById("opponentBattlefield");
        opponentBF.innerHTML = "";
        ai.battlefield.forEach((minion, index) => {
          let effectiveAttack = getEffectiveAttack(minion, "ai");
          let div = document.createElement("div");
          div.className = "minion";
          div.innerText = minion.name + "\n" + effectiveAttack + "/" + minion.currentHP;
          div.onclick = () => { if (selectedAttacker) attackMinion(index); };
          opponentBF.appendChild(div);
        });

        let handContainer = document.getElementById("handContainer");
        handContainer.innerHTML = "";
        player.hand.forEach((cardKey, index) => {
          let card = cardTemplates[cardKey];
          let div = document.createElement("div");
          div.className = "card";
          div.innerText = card.name + "\nCost: " + card.cost;
          div.onclick = () => playCard(index);
          handContainer.appendChild(div);
        });

        let opponentHand = document.getElementById("opponentHand");
        opponentHand.innerHTML = "";
        ai.hand.forEach((cardKey, index) => {
          let card = cardTemplates[cardKey];
          let div = document.createElement("div");
          div.className = "card";
          div.innerText = card.name + "\nCost: " + card.cost;
          opponentHand.appendChild(div);
        });

        // Display "Upgrade Units" button if any group of same minions (non-hero) exists with 2 or more.
        let groups = {};
        player.battlefield.forEach(unit => {
          if(unit.type === "minion") {
            groups[unit.name] = (groups[unit.name] || 0) + 1;
          }
        });
        let canUpgrade = Object.values(groups).some(count => count >= 2);
        document.getElementById("upgradeButton").style.display = canUpgrade ? "inline-block" : "none";

        document.getElementById("activateAbilityButton").style.display = (selectedAttacker && selectedAttacker.minion.ability && !selectedAttacker.minion.abilityUsed) ? "inline-block" : "none";
      }

      function logMessage(msg) {
        document.getElementById("message").innerText = msg;
      }

      // If opponent battlefield is clicked (and no enemy minions exist), treat as attack on the Hero.
      document.getElementById("opponentBattlefield").onclick = function(e) {
        if (ai.battlefield.length === 0 && selectedAttacker) {
          attackHero();
        }
      };

      /***** UPGRADE UNITS (COMBINE) *****/
      function upgradeUnits() {
        // Find groups of same minion on player's battlefield.
        let counts = {};
        player.battlefield.forEach(u => {
          if(u.type === "minion") counts[u.name] = (counts[u.name] || 0) + 1;
        });
        let upgradable = Object.keys(counts).filter(name => counts[name] >= 2);
        if (upgradable.length === 0) {
          logMessage("No units available for upgrade.");
          return;
        }
        let choice = prompt("Enter the unit type to upgrade (" + upgradable.join(", ") + "):");
        if (!choice || !upgradable.includes(choice)) {
          logMessage("Invalid choice.");
          return;
        }
        let units = player.battlefield.filter(u => u.name === choice || u.name === (choice + " (Upgraded)"));
        if (units.length < 2) {
          logMessage("Not enough units to upgrade.");
          return;
        }
        let totalAttack = units.reduce((sum, u) => sum + u.attack, 0);
        let totalHP = units.reduce((sum, u) => sum + u.currentHP, 0);
        totalAttack += 1;
        totalHP += 1;
        // Remove these units.
        player.battlefield = player.battlefield.filter(u => u.name !== choice && u.name !== (choice + " (Upgraded)"));
        let upgraded = Object.assign({}, cardTemplates[units[0].cardKey || choice]);
        upgraded.attack = totalAttack;
        upgraded.hp = totalHP;
        upgraded.currentHP = totalHP;
        upgraded.name = choice + " (Upgraded)";
        upgraded.attacked = false;
        upgraded.abilityUsed = false;
        player.battlefield.push(upgraded);
        logMessage("Upgraded " + units.length + " " + choice + "(s) into one unit with " + totalAttack + " attack and " + totalHP + " HP.");
        updateUI();
      }

      window.onload = function() {
        populateAvailableCards();
        populateSelectedDeck();
        updateDeckCount();
      };
    </script>
  </body>
</html>
