<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>CHEGG Card Game Variant – Biomes & Elemental Effects</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        background: #f4f4f4;
        margin: 0;
        padding: 10px;
      }
      h1 {
        text-align: center;
      }
      #gameContainer {
        max-width: 1200px;
        margin: 0 auto;
        background: #fff;
        padding: 10px;
        box-shadow: 0 0 10px rgba(0,0,0,0.2);
      }
      .section {
        margin-bottom: 15px;
      }
      .area {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 5px;
        border: 1px solid #ccc;
        background: #e9e9e9;
        margin-bottom: 5px;
      }
      .battlefield, .hand, .biomeZone {
        min-height: 80px;
        padding: 5px;
        border: 1px dashed #888;
        background: #fff;
        margin: 5px 0;
      }
      .card, .minion {
        display: inline-block;
        border: 1px solid #333;
        border-radius: 4px;
        background: #fafafa;
        padding: 5px;
        margin: 5px;
        cursor: pointer;
        white-space: pre-line;
      }
      .selected {
        border: 2px solid #f80;
        background: #fffae6;
      }
      #message {
        margin-top: 10px;
        padding: 5px;
        background: #eef;
        border: 1px solid #99f;
      }
      #controls {
        text-align: center;
        margin-top: 10px;
      }
      button {
        margin: 5px;
        padding: 8px 16px;
        font-size: 16px;
      }
      .info {
        font-size: 18px;
      }
      .biomeZone {
        font-style: italic;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <h1>CHEGG Card Game Variant – Biomes & Elemental Effects</h1>
      <!-- Opponent Info -->
      <div class="section">
        <div class="area">
          <div>
            <strong>Opponent Villager</strong><br>
            <span id="opponentHeroHP" class="info"></span>
          </div>
          <div>
            <strong>Opponent Mana</strong><br>
            <span id="opponentMana" class="info"></span>
          </div>
        </div>
        <div class="area">
          <div style="width:32%;">
            <strong>Opponent Biome</strong>
            <div id="opponentBiome" class="biomeZone"></div>
          </div>
          <div style="width:32%;">
            <strong>Opponent Battlefield</strong>
            <div id="opponentBattlefield" class="battlefield"></div>
          </div>
          <div style="width:32%;">
            <strong>Opponent Hand</strong>
            <div id="opponentHand" class="hand"></div>
          </div>
        </div>
      </div>
      
      <!-- Player Info -->
      <div class="section">
        <div class="area">
          <div>
            <strong>Your Villager</strong><br>
            <span id="playerHeroHP" class="info"></span>
          </div>
          <div>
            <strong>Your Mana</strong><br>
            <span id="playerMana" class="info"></span>
          </div>
        </div>
        <div class="area">
          <div style="width:32%;">
            <strong>Your Biome</strong>
            <div id="playerBiome" class="biomeZone"></div>
          </div>
          <div style="width:32%;">
            <strong>Your Battlefield</strong>
            <div id="playerBattlefield" class="battlefield"></div>
          </div>
          <div style="width:32%;">
            <strong>Your Hand</strong>
            <div id="handContainer" class="hand"></div>
          </div>
        </div>
      </div>
      
      <!-- Controls -->
      <div id="controls" class="section">
        <button onclick="endTurn()" id="endTurnButton">End Turn</button>
        <button onclick="activateSelectedAbility()" id="activateAbilityButton" style="display:none;">Activate Ability</button>
        <button onclick="initGame()">Restart Game</button>
      </div>
      
      <!-- Message Log -->
      <div id="message" class="section">Welcome to CHEGG Card Game!</div>
    </div>
    
    <script>
      /***** GAME CONFIGURATION *****/
      const MAX_MANA = 6;
      const STARTING_HP = 20;
      
      // Card templates with new properties for element, strengths, and weaknesses.
      const cardTemplates = {
        "Villager": { 
          type: "hero", 
          name: "Villager", 
          cost: 0, 
          attack: 0, 
          hp: STARTING_HP 
        },
        "Zombie": { 
          type: "minion", 
          name: "Zombie", 
          cost: 1, 
          attack: 1, 
          hp: 1, 
          element: "undead", 
          strengths: [], 
          weaknesses: ["fire"] 
        },
        "Creeper": { 
          type: "minion", 
          name: "Creeper", 
          cost: 1, 
          attack: 1, 
          hp: 1, 
          element: "undead", 
          strengths: [], 
          weaknesses: ["water"],
          ability: "explode" 
        },
        "Pig": { 
          type: "minion", 
          name: "Pig", 
          cost: 1, 
          attack: 0, 
          hp: 1, 
          element: "beast", 
          strengths: [], 
          weaknesses: [],
          ability: "support" 
        },
        "Rabbit": { 
          type: "minion", 
          name: "Rabbit", 
          cost: 2, 
          attack: 1, 
          hp: 1, 
          element: "beast", 
          strengths: [], 
          weaknesses: [],
          ability: "hop" 
        },
        "PufferFish": { 
          type: "minion", 
          name: "Puffer-Fish", 
          cost: 2, 
          attack: 1, 
          hp: 1, 
          element: "water", 
          strengths: ["fire"], 
          weaknesses: ["electric"],
          ability: "splash" 
        },
        "IronGolem": { 
          type: "minion", 
          name: "Iron-Golem", 
          cost: 2, 
          attack: 2, 
          hp: 3, 
          element: "earth", 
          strengths: ["undead"], 
          weaknesses: ["water"],
          ability: "sweep" 
        },
        "Frog": { 
          type: "minion", 
          name: "Frog", 
          cost: 2, 
          attack: 0, 
          hp: 2, 
          element: "water", 
          strengths: [], 
          weaknesses: ["fire"],
          ability: "pull" 
        },
        "Skeleton": { 
          type: "minion", 
          name: "Skeleton", 
          cost: 3, 
          attack: 3, 
          hp: 2, 
          element: "undead", 
          strengths: [], 
          weaknesses: ["fire"] 
        },
        "Blaze": { 
          type: "minion", 
          name: "Blaze", 
          cost: 3, 
          attack: 3, 
          hp: 2, 
          element: "fire", 
          strengths: ["undead"], 
          weaknesses: ["water"],
          ability: "ranged" 
        },
        "Phantom": { 
          type: "minion", 
          name: "Phantom", 
          cost: 3, 
          attack: 2, 
          hp: 1, 
          element: "air", 
          strengths: [], 
          weaknesses: ["earth"],
          ability: "shadow" 
        },
        "Enderman": { 
          type: "minion", 
          name: "Enderman", 
          cost: 4, 
          attack: 3, 
          hp: 2, 
          element: "dark", 
          strengths: [], 
          weaknesses: ["light"],
          ability: "teleport" 
        },
        "Slime": { 
          type: "minion", 
          name: "Slime", 
          cost: 4, 
          attack: 2, 
          hp: 3, 
          element: "earth", 
          strengths: [], 
          weaknesses: ["fire"],
          ability: "jump" 
        },
        "ShulkerBox": { 
          type: "minion", 
          name: "Shulker-Box", 
          cost: 4, 
          attack: 1, 
          hp: 4, 
          element: "metal", 
          strengths: [], 
          weaknesses: ["earth"],
          ability: "longshot" 
        },
        "Parrot": { 
          type: "minion", 
          name: "Parrot", 
          cost: 5, 
          attack: 3, 
          hp: 2, 
          element: "air", 
          strengths: [], 
          weaknesses: ["electric"],
          ability: "copy" 
        },
        "Cat": { 
          type: "minion", 
          name: "Cat", 
          cost: 5, 
          attack: 0, 
          hp: 2, 
          element: "beast", 
          strengths: [], 
          weaknesses: [],
          ability: "manaBoost" 
        },
        "Sniffer": { 
          type: "minion", 
          name: "Sniffer", 
          cost: 5, 
          attack: 2, 
          hp: 2, 
          element: "beast", 
          strengths: [], 
          weaknesses: [],
          ability: "disrupt" 
        },
        "Wither": { 
          type: "minion", 
          name: "Wither", 
          cost: 6, 
          attack: 4, 
          hp: 3, 
          element: "undead", 
          strengths: ["beast"], 
          weaknesses: ["fire"],
          ability: "explosiveWither" 
        },
        "Reinforcement": { 
          type: "spell", 
          name: "Reinforcement", 
          cost: 2, 
          effect: "draw2" 
        },
        "Lightning": { 
          type: "spell", 
          name: "Lightning", 
          cost: 3, 
          effect: "lightning", 
          damage: 3 
        },
        "Heal": { 
          type: "spell", 
          name: "Heal", 
          cost: 3, 
          effect: "heal", 
          amount: 3 
        },
        "Forest": { 
          type: "biome", 
          name: "Forest", 
          cost: 3, 
          effect: "boost", 
          elementTarget: "beast", 
          bonus: 1 
        },
        "Desert": { 
          type: "biome", 
          name: "Desert", 
          cost: 3, 
          effect: "weaken", 
          elementTarget: "water", 
          penalty: 1 
        }
      };
      
      /***** GAME STATE *****/
      let currentTurn = "player"; // "player" or "ai"
      let turnNumber = 1;
      
      let player = {
        hero: null,
        deck: [],
        hand: [],
        battlefield: [],
        biome: null,
        currentMana: 0,
        maxMana: 0
      };
      
      let ai = {
        hero: null,
        deck: [],
        hand: [],
        battlefield: [],
        biome: null,
        currentMana: 0,
        maxMana: 0
      };
      
      // For selecting a minion for attack/ability activation.
      let selectedAttacker = null;
      
      /***** INITIALIZATION *****/
      function initGame() {
        turnNumber = 1;
        currentTurn = "player";
        selectedAttacker = null;
        player.biome = null;
        ai.biome = null;
        
        // Create heroes.
        player.hero = Object.assign({}, cardTemplates["Villager"]);
        ai.hero = Object.assign({}, cardTemplates["Villager"]);
        
        // Build decks.
        player.deck = buildDeck();
        ai.deck = buildDeck();
        
        // Shuffle decks.
        player.deck.sort(() => Math.random() - 0.5);
        ai.deck.sort(() => Math.random() - 0.5);
        
        // Clear hands, battlefields.
        player.hand = [];
        ai.hand = [];
        player.battlefield = [];
        ai.battlefield = [];
        
        // Draw initial hand (5 cards).
        for (let i = 0; i < 5; i++) {
          drawCard("player");
          drawCard("ai");
        }
        
        // Initialize mana (starting at 1).
        player.maxMana = 1;
        player.currentMana = 1;
        ai.maxMana = 1;
        ai.currentMana = 1;
        
        updateUI();
        logMessage("Game started! Your turn begins.");
        startTurn("player");
      }
      
      function buildDeck() {
        let deck = [];
        let counts = {
          "Zombie": 6, "Creeper": 3, "Pig": 3, "Rabbit": 2, "PufferFish": 2,
          "IronGolem": 2, "Frog": 2, "Skeleton": 3, "Blaze": 2, "Phantom": 2,
          "Enderman": 2, "Slime": 2, "ShulkerBox": 2, "Parrot": 1, "Cat": 1,
          "Sniffer": 1, "Wither": 1, "Reinforcement": 3, "Lightning": 2,
          "Heal": 2, "Forest": 1, "Desert": 1
        };
        for (let card in counts) {
          for (let i = 0; i < counts[card]; i++) {
            deck.push(card);
          }
        }
        return deck;
      }
      
      function drawCard(side) {
        let p = (side === "player") ? player : ai;
        if (p.deck.length > 0) {
          let cardKey = p.deck.shift();
          p.hand.push(cardKey);
        } else {
          logMessage(side + " has no cards left in the deck!");
        }
      }
      
      /***** TURN MANAGEMENT *****/
      function startTurn(side) {
        currentTurn = side;
        if (side === "player") {
          turnNumber++;
          // Ramp player's mana.
          player.maxMana = Math.min(player.maxMana + 1, MAX_MANA);
          if (player.battlefield.some(m => m.name === "Cat")) {
            player.maxMana = Math.min(player.maxMana + 1, MAX_MANA);
          }
          player.currentMana = player.maxMana;
          drawCard("player");
          logMessage("Your turn. You have " + player.currentMana + " mana.");
          updateUI();
        } else {
          // Ramp AI mana.
          ai.maxMana = Math.min(ai.maxMana + 1, MAX_MANA);
          ai.currentMana = ai.maxMana;
          drawCard("ai");
          logMessage("AI turn. AI has " + ai.currentMana + " mana.");
          updateUI();
          setTimeout(aiTurn, 1000);
        }
      }
      
      function endTurn() {
        if (currentTurn !== "player") return;
        logMessage("Ending your turn.");
        // Reset flags.
        player.battlefield.forEach(m => { m.attacked = false; m.abilityUsed = false; });
        currentTurn = "ai";
        updateUI();
        setTimeout(aiTurn, 1000);
      }
      
      /***** PLAYER ACTIONS *****/
      function playCard(index) {
        if (currentTurn !== "player") return;
        let cardKey = player.hand[index];
        let cardTemplate = cardTemplates[cardKey];
        if (player.currentMana < cardTemplate.cost) {
          logMessage("Not enough mana to play " + cardTemplate.name + ".");
          return;
        }
        player.currentMana -= cardTemplate.cost;
        player.hand.splice(index, 1);
        // If the card is a biome, set it as active.
        if (cardTemplate.type === "biome") {
          player.biome = Object.assign({}, cardTemplate);
          logMessage("You set your biome to " + cardTemplate.name + ".");
        }
        else if (cardTemplate.type === "minion") {
          let minion = Object.assign({}, cardTemplate);
          minion.currentHP = cardTemplate.hp;
          minion.attacked = false;
          minion.abilityUsed = false;
          player.battlefield.push(minion);
          if (minion.ability === "support") {
            drawCard("player");
            logMessage("Pig's support activated: you draw 1 card.");
          }
          logMessage("You summoned a " + minion.name + ".");
        } else if (cardTemplate.type === "spell") {
          if (cardTemplate.effect === "draw2") {
            drawCard("player");
            drawCard("player");
            logMessage("You cast Reinforcement and drew 2 cards.");
          } else if (cardTemplate.effect === "lightning") {
            // Lightning: if opponent has minions, deal damage to the first one; else, to hero.
            if (ai.battlefield.length > 0) {
              ai.battlefield[0].currentHP -= cardTemplate.damage;
              logMessage("You cast Lightning on " + ai.battlefield[0].name + " for " + cardTemplate.damage + " damage.");
              if (ai.battlefield[0].currentHP <= 0) {
                logMessage(ai.battlefield[0].name + " was destroyed.");
                ai.battlefield.shift();
              }
            } else {
              ai.hero.hp -= cardTemplate.damage;
              logMessage("You cast Lightning on the opponent's Villager for " + cardTemplate.damage + " damage.");
            }
          } else if (cardTemplate.effect === "heal") {
            player.hero.hp += cardTemplate.amount;
            logMessage("You cast Heal and restored " + cardTemplate.amount + " HP to your Villager.");
          }
        }
        updateUI();
      }
      
      function selectAttacker(index) {
        if (currentTurn !== "player") return;
        let attacker = player.battlefield[index];
        if (attacker.attacked) {
          logMessage("This minion has already attacked.");
          return;
        }
        selectedAttacker = { minion: attacker, index: index };
        logMessage("Selected " + attacker.name + ". Click an enemy minion to attack or click the opponent's battlefield (if no enemy minions remain) to attack the hero.");
        updateUI();
      }
      
      function attackHero() {
        if (!selectedAttacker) return;
        if (ai.battlefield.length > 0) {
          logMessage("You must attack enemy minions before targeting the hero.");
          return;
        }
        let attacker = selectedAttacker.minion;
        let bonus = 0;
        if (attacker.ability === "shadow" && !attacker.abilityUsed) {
          bonus = attacker.attack;
          attacker.abilityUsed = true;
          logMessage("Phantom's Shadow activated: damage doubled.");
        }
        ai.hero.hp -= (attacker.attack + bonus);
        attacker.attacked = true;
        logMessage("Your " + attacker.name + " attacked the opponent's Villager for " + (attacker.attack + bonus) + " damage.");
        selectedAttacker = null;
        checkVictory();
        updateUI();
      }
      
      function attackMinion(aiIndex) {
        if (!selectedAttacker) return;
        let attacker = selectedAttacker.minion;
        let defender = ai.battlefield[aiIndex];
        // Calculate effective attack considering biomes.
        let attackerDamage = getEffectiveAttack(attacker, "player");
        let defenderDamage = getEffectiveAttack(defender, "ai");
        // Apply elemental multipliers.
        let multiplier = 1;
        if (attacker.element && defender.weaknesses && defender.weaknesses.includes(attacker.element)) {
          multiplier = 2;
        } else if (attacker.element && defender.strengths && defender.strengths.includes(attacker.element)) {
          multiplier = 0.5;
        }
        let damageToDefender = Math.floor(attackerDamage * multiplier);
        let damageToAttacker = defenderDamage; // For simplicity, defender deals full damage.
        defender.currentHP -= damageToDefender;
        attacker.currentHP -= damageToAttacker;
        logMessage("Your " + attacker.name + " attacked " + defender.name + " (Damage: " + damageToDefender + " vs " + damageToAttacker + ").");
        attacker.attacked = true;
        if (defender.currentHP <= 0) {
          logMessage("Opponent's " + defender.name + " was destroyed.");
          ai.battlefield.splice(aiIndex, 1);
        }
        if (attacker.currentHP <= 0) {
          logMessage("Your " + attacker.name + " was destroyed in combat.");
          player.battlefield.splice(selectedAttacker.index, 1);
        }
        selectedAttacker = null;
        checkVictory();
        updateUI();
      }
      
      function activateSelectedAbility() {
        if (!selectedAttacker) {
          logMessage("No minion selected for ability activation.");
          return;
        }
        let attacker = selectedAttacker.minion;
        if (!attacker.ability || attacker.abilityUsed) {
          logMessage("This minion has no available ability.");
          return;
        }
        activateAbility("player", selectedAttacker.index);
        selectedAttacker = null;
        updateUI();
      }
      
      /***** ABILITY FUNCTIONS *****/
      function activateAbility(side, index) {
        let p = (side === "player") ? player : ai;
        let opponent = (side === "player") ? ai : player;
        let minion = p.battlefield[index];
        if (minion.abilityUsed) return;
        switch(minion.ability) {
          case "explode":
            opponent.battlefield.forEach(m => m.currentHP -= 1);
            opponent.hero.hp -= 1;
            logMessage(minion.name + " explodes, dealing 1 damage to all enemy units and hero!");
            p.battlefield.splice(index, 1);
            break;
          case "hop":
            drawCard(side);
            logMessage(minion.name + " hops and draws 1 card!");
            minion.abilityUsed = true;
            break;
          case "splash":
            opponent.battlefield.forEach(m => m.currentHP -= 1);
            logMessage(minion.name + " splashes, dealing 1 damage to all enemy minions!");
            minion.abilityUsed = true;
            break;
          case "sweep":
            opponent.battlefield.forEach(m => m.currentHP -= 1);
            logMessage(minion.name + " sweeps, damaging all enemy minions!");
            minion.abilityUsed = true;
            break;
          case "pull":
            if (opponent.battlefield.length > 0) {
              let target = opponent.battlefield[0];
              target.attack = Math.max(0, target.attack - 1);
              logMessage(minion.name + " pulls, reducing " + target.name + "'s attack by 1 for this turn.");
              minion.abilityUsed = true;
            }
            break;
          case "ranged":
            if (opponent.battlefield.length > 0) {
              let target = opponent.battlefield[0];
              target.currentHP -= 2;
              logMessage(minion.name + " uses Ranged attack on " + target.name + " for 2 damage!");
              minion.abilityUsed = true;
              if (target.currentHP <= 0) {
                logMessage(target.name + " was destroyed.");
                opponent.battlefield.shift();
              }
            }
            break;
          case "teleport":
            if (p.battlefield.length > 1) {
              let target = p.battlefield.find((m, i) => i !== index);
              if (target) {
                [p.battlefield[index], p.battlefield[p.battlefield.indexOf(target)]] = [target, minion];
                logMessage(minion.name + " teleports, swapping positions with " + target.name + ".");
                minion.abilityUsed = true;
              }
            }
            break;
          case "jump":
            opponent.hero.hp -= 1;
            opponent.battlefield.forEach(m => m.currentHP -= 1);
            logMessage(minion.name + " jumps, dealing 1 damage to enemy hero and all enemy minions!");
            minion.abilityUsed = true;
            break;
          case "longshot":
            if (opponent.battlefield.length > 0) {
              let target = opponent.battlefield[0];
              target.currentHP -= 2;
              logMessage(minion.name + " fires a long shot at " + target.name + " for 2 damage!");
              minion.abilityUsed = true;
              if (target.currentHP <= 0) {
                logMessage(target.name + " was destroyed.");
                opponent.battlefield.shift();
              }
            }
            break;
          case "copy":
            let friendly = p.battlefield.slice().reverse().find(m => m.ability && m !== minion);
            if (friendly) {
              logMessage(minion.name + " copies " + friendly.name + "'s ability (no additional effect).");
              minion.abilityUsed = true;
            }
            break;
          case "manaBoost":
            logMessage(minion.name + " passively boosts your mana each turn.");
            break;
          case "disrupt":
            if (opponent.hand.length > 0) {
              opponent.hand.splice(Math.floor(Math.random() * opponent.hand.length), 1);
              logMessage(minion.name + " disrupts and forces opponent to discard a card!");
              minion.abilityUsed = true;
            }
            break;
          case "explosiveWither":
            opponent.battlefield.forEach(m => m.currentHP -= 2);
            opponent.hero.hp -= 2;
            logMessage(minion.name + " unleashes Explosive Wither, dealing 2 damage to all enemies!");
            minion.abilityUsed = true;
            break;
          default:
            logMessage("No ability to activate.");
        }
        opponent.battlefield = opponent.battlefield.filter(m => m.currentHP > 0);
      }
      
      /***** BIOME EFFECTS & EFFECTIVE ATTACK *****/
      function getEffectiveAttack(unit, owner) {
        let effective = unit.attack;
        let biome = (owner === "player") ? player.biome : ai.biome;
        if (biome) {
          if (biome.effect === "boost" && unit.element === biome.elementTarget) {
            effective += biome.bonus;
          } else if (biome.effect === "weaken" && unit.element === biome.elementTarget) {
            effective = Math.max(0, effective - biome.penalty);
          }
        }
        return effective;
      }
      
      /***** AI TURN – SINGLE ACTION *****/
      function aiTurn() {
        // AI takes one action per turn.
        let actionTaken = false;
        
        // 1. Try to play a card.
        for (let i = 0; i < ai.hand.length; i++) {
          let cardKey = ai.hand[i];
          let cardTemplate = cardTemplates[cardKey];
          if (ai.currentMana >= cardTemplate.cost) {
            ai.currentMana -= cardTemplate.cost;
            ai.hand.splice(i, 1);
            if (cardTemplate.type === "biome") {
              ai.biome = Object.assign({}, cardTemplate);
              logMessage("AI sets its biome to " + cardTemplate.name + ".");
            }
            else if (cardTemplate.type === "minion") {
              let minion = Object.assign({}, cardTemplate);
              minion.currentHP = cardTemplate.hp;
              minion.attacked = false;
              minion.abilityUsed = false;
              ai.battlefield.push(minion);
              logMessage("AI summoned a " + minion.name + ".");
            } else if (cardTemplate.type === "spell") {
              if (cardTemplate.effect === "draw2") {
                drawCard("ai");
                drawCard("ai");
                logMessage("AI cast Reinforcement.");
              } else if (cardTemplate.effect === "lightning") {
                if (player.battlefield.length > 0) {
                  player.battlefield[0].currentHP -= cardTemplate.damage;
                  logMessage("AI cast Lightning on your " + player.battlefield[0].name + " for " + cardTemplate.damage + " damage.");
                  if (player.battlefield[0].currentHP <= 0) {
                    logMessage("Your " + player.battlefield[0].name + " was destroyed.");
                    player.battlefield.shift();
                  }
                } else {
                  player.hero.hp -= cardTemplate.damage;
                  logMessage("AI cast Lightning on your Villager for " + cardTemplate.damage + " damage.");
                }
              } else if (cardTemplate.effect === "heal") {
                ai.hero.hp += cardTemplate.amount;
                logMessage("AI cast Heal and restored " + cardTemplate.amount + " HP to its Villager.");
              }
            }
            actionTaken = true;
            break;
          }
        }
        
        // 2. If no card was played, try to attack with a minion.
        if (!actionTaken) {
          for (let i = 0; i < ai.battlefield.length; i++) {
            let minion = ai.battlefield[i];
            if (!minion.attacked) {
              if (player.battlefield.length > 0) {
                let defender = player.battlefield[0];
                let attackerDamage = getEffectiveAttack(minion, "ai");
                let defenderDamage = getEffectiveAttack(defender, "player");
                let multiplier = 1;
                if (minion.element && defender.weaknesses && defender.weaknesses.includes(minion.element)) {
                  multiplier = 2;
                } else if (minion.element && defender.strengths && defender.strengths.includes(minion.element)) {
                  multiplier = 0.5;
                }
                let damageToDefender = Math.floor(attackerDamage * multiplier);
                let damageToAttacker = defenderDamage;
                defender.currentHP -= damageToDefender;
                minion.currentHP -= damageToAttacker;
                logMessage("AI's " + minion.name + " attacked your " + defender.name + " (Damage: " + damageToDefender + " vs " + damageToAttacker + ").");
                if (defender.currentHP <= 0) {
                  logMessage("Your " + defender.name + " was destroyed.");
                  player.battlefield.shift();
                }
              } else {
                player.hero.hp -= getEffectiveAttack(minion, "ai");
                logMessage("AI's " + minion.name + " attacked your Villager for " + getEffectiveAttack(minion, "ai") + " damage.");
              }
              minion.attacked = true;
              actionTaken = true;
              break;
            }
          }
        }
        
        // 3. If no card played and no attack available, try to activate an ability.
        if (!actionTaken) {
          for (let i = 0; i < ai.battlefield.length; i++) {
            let minion = ai.battlefield[i];
            if (minion.ability && !minion.abilityUsed) {
              activateAbility("ai", i);
              actionTaken = true;
              break;
            }
          }
        }
        
        // End AI turn.
        checkVictory();
        ai.battlefield.forEach(m => { m.attacked = false; m.abilityUsed = false; });
        player.battlefield.forEach(m => { m.attacked = false; m.abilityUsed = false; });
        currentTurn = "player";
        // Ramp up player's mana.
        player.maxMana = Math.min(player.maxMana + 1, MAX_MANA);
        if (player.battlefield.some(m => m.name === "Cat")) {
          player.maxMana = Math.min(player.maxMana + 1, MAX_MANA);
        }
        player.currentMana = player.maxMana;
        drawCard("player");
        logMessage("Your turn begins.");
        updateUI();
      }
      
      /***** VICTORY CHECK *****/
      function checkVictory() {
        if (player.hero.hp <= 0) {
          logMessage("Your Villager has been defeated. You lose!");
          currentTurn = "gameover";
        }
        if (ai.hero.hp <= 0) {
          logMessage("Opponent's Villager has been defeated. You win!");
          currentTurn = "gameover";
        }
      }
      
      /***** UI UPDATES *****/
      function updateUI() {
        document.getElementById("playerHeroHP").innerText = player.hero.hp;
        document.getElementById("opponentHeroHP").innerText = ai.hero.hp;
        document.getElementById("playerMana").innerText = player.currentMana + " / " + player.maxMana;
        document.getElementById("opponentMana").innerText = ai.currentMana + " / " + ai.maxMana;
        
        // Update biome zones.
        let playerBiomeDiv = document.getElementById("playerBiome");
        playerBiomeDiv.innerText = player.biome ? player.biome.name : "None";
        let opponentBiomeDiv = document.getElementById("opponentBiome");
        opponentBiomeDiv.innerText = ai.biome ? ai.biome.name : "None";
        
        // Update battlefields.
        let playerBF = document.getElementById("playerBattlefield");
        playerBF.innerHTML = "";
        player.battlefield.forEach((minion, index) => {
          let effectiveAttack = getEffectiveAttack(minion, "player");
          let div = document.createElement("div");
          div.className = "minion" + (selectedAttacker && selectedAttacker.index === index ? " selected" : "");
          div.innerText = minion.name + "\n" + effectiveAttack + "/" + minion.currentHP;
          div.onclick = () => selectAttacker(index);
          playerBF.appendChild(div);
        });
        
        let opponentBF = document.getElementById("opponentBattlefield");
        opponentBF.innerHTML = "";
        ai.battlefield.forEach((minion, index) => {
          let effectiveAttack = getEffectiveAttack(minion, "ai");
          let div = document.createElement("div");
          div.className = "minion";
          div.innerText = minion.name + "\n" + effectiveAttack + "/" + minion.currentHP;
          div.onclick = () => { if(selectedAttacker) attackMinion(index); };
          opponentBF.appendChild(div);
        });
        
        // Update hands.
        let handContainer = document.getElementById("handContainer");
        handContainer.innerHTML = "";
        player.hand.forEach((cardKey, index) => {
          let card = cardTemplates[cardKey];
          let div = document.createElement("div");
          div.className = "card";
          div.innerText = card.name + "\nCost: " + card.cost;
          div.onclick = () => playCard(index);
          handContainer.appendChild(div);
        });
        
        let opponentHand = document.getElementById("opponentHand");
        opponentHand.innerHTML = "";
        ai.hand.forEach((cardKey, index) => {
          let card = cardTemplates[cardKey];
          let div = document.createElement("div");
          div.className = "card";
          div.innerText = card.name + "\nCost: " + card.cost;
          opponentHand.appendChild(div);
        });
        
        // Show Activate Ability button if applicable.
        if (selectedAttacker && selectedAttacker.minion.ability && !selectedAttacker.minion.abilityUsed) {
          document.getElementById("activateAbilityButton").style.display = "inline-block";
        } else {
          document.getElementById("activateAbilityButton").style.display = "none";
        }
      }
      
      function logMessage(msg) {
        document.getElementById("message").innerText = msg;
      }
      
      // If opponent battlefield is clicked (and no enemy minions exist), treat it as an attack on hero.
      document.getElementById("opponentBattlefield").onclick = function(e) {
        if (ai.battlefield.length === 0 && selectedAttacker) {
          attackHero();
        }
      }
      
      document.getElementById("opponentArea").onclick = function(e) {
        if ((e.target.id === "opponentHeroHP" || e.target.parentNode.id === "opponentArea") && ai.battlefield.length === 0) {
          if (selectedAttacker) {
            attackHero();
          }
        }
      }
      
      window.onload = initGame;
    </script>
  </body>
</html>
